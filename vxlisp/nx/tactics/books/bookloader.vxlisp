(package nx/tactics/books/bookloader
 :libs (lib base :path nx/tactics/base)
       (lib fil  :path vx/data/file)
       (lib typ  :path vx/type)
       (lib xml  :path vx/data/xml)
 :doc "Book loading tools")

(func ability<-ability-key-value : base/ability
 [current : base/ability
  key     : string
  value   : string]
 (switch : base/ability
  key
  (case "" current)
  (case
   (list
    "name"
    "image")
   (copy current
    key value))
  (else
   (copy current
    (msg<-error
     :invalidproperty
     (anymap
      :type  base/ability
      :prop  key
      :value value)))))
 :doc "Returns a modified ability from a key value.")

(func ability<-ability-stringmap : base/ability
 [ability : base/ability
  propmap : stringmap]
 (any<-map-start-reduce : base/ability
  propmap
  ability
  ability<-ability-key-value)
 :test (test
        (base/ability
         :name "name"
         :image "image")
        (ability<-ability-stringmap
         (empty base/ability)
         (stringmap
          :name "name"
          :image "image")))
 :doc "Returns a new ability from a propmap.")

(func ability<-ability-xmlchild : base/ability
 [ability : base/ability
  child   : xml/xml]
 (let : base/ability
  [tag : string := (:tag child)]
  (switch : base/ability
   tag
   (case "" ability)
   (case
    (list
     "reference"
     "summary"
     "titles")
    (copy ability
     tag
     (xml/string-first<-xml
      child)))
   (else
    (copy ability
     (msg<-error
      :invalidtagfound
      (anymap
       :type base/ability
       :tag tag))))))
 :test (test
        (base/ability
         :titles "titles")
        (ability<-ability-xmlchild
         (empty base/ability)
         (xml/xml
          :tag "titles"
          :children
           (xml/xmllist
            (xml/xml
             :text "titles")))))
 :doc "Returns a modified ability based on a given child xml.")

(func ability<-xml : base/ability
 [xml : xml/xml]
 (let : base/ability
  [propmap : stringmap := (:propmap xml)
   ability : base/ability :=
    (ability<-ability-stringmap
     (empty base/ability)
     propmap)]
  (any<-list-start-reduce : base/ability
   (:children xml)
   ability
   ability<-ability-xmlchild))
 :test (test
        (base/ability
         :name "name"
         :image "image"
         :titles "titles"
         :reference "reference")
        (ability<-xml
         (xml/xml
          :tag "ability"
          :propmap
           (stringmap
            :name "name"
            :image "image")
          :children
           (xml/xmllist
            (xml/xml
             :tag "titles"
             :children
              (xml/xmllist
               (xml/xml
                :text "titles")))
            (xml/xml
             :tag "reference"
             :children
              (xml/xmllist
               (xml/xml
                :text "reference")))))))
 :doc "Returns a ability from a given xml.")

(func book<-book-key-value : base/book
 [current : base/book
  key     : string
  value   : string]
 (switch : base/book
  key
  (case "" current)
  (case
   (list
    "name"
    "image")
   (copy current
    key value))
  (else
   (copy current
    (msg<-error
     :invalidproperty
     (anymap
      :type  base/book
      :prop  key
      :value value)))))
 :test (test
        (base/book
         :name "nm")
        (book<-book-key-value
         (empty base/book)
         "name"
         "nm"))
       (test
        (base/book
         :name "image")
        (book<-book-key-value
         (empty base/book)
         "name"
         "image"))
 :doc "Returns a modified book from a key value.")

(func book<-book-stringmap : base/book
 [book    : base/book
  propmap : stringmap]
 (any<-map-start-reduce : base/book
  propmap
  book
  book<-book-key-value)
 :test (test
        (base/book
         :name "name"
         :image "image")
        (book<-book-stringmap
         (empty base/book)
         (stringmap
          :name "name"
          :image "image")))
 :doc "Returns a new book from a propmap.")

(func book<-book-xml : base/book
 [current : base/book
  child   : xml/xml]
 (let : base/book
  [tag : string := (:tag child)]
  (switch : base/book
   tag
   (case "" current)
   (case "!--" current)
   (case "?xml" current)
   (case "doc"
    (if : base/book
     (then
      (is-empty current)
      (book<-xmldoc
       child))
     (else
      (copy current
       (msg<-error
        :duplicatetagfound
        (anymap
         :type base/book
         :tag tag))))))
   (else
    (copy current
     (msg<-error
      :invalidtagfound
      (anymap
       :type base/book
       :tag tag))))))
 :test (test
        (base/book
         :name "name1")
        (book<-book-xml
         (empty base/book)
         (xml/xml
          :tag "doc"
          :propmap
           (stringmap
            :name "name1"))))
       (test
        (empty base/book)
        (book<-book-xml
         (empty base/book)
         (xml/xml
          :tag "?xml")))
       (test
        (base/book
         :name "name1"
         (msgblock
          (msg
           :code ":duplicatetagfound"
           :detail
            (anymap
             :type nx/tactics/base/book
             :tag "doc")
             :severity 2)))
        (book<-book-xml
         (base/book
          :name "name1")
         (xml/xml
          :tag "doc")))
 :doc "Returns an altered book based on xml child.")

(func book<-book-xmlchapter : base/book
 [book : base/book
  xml  : xml/xml]
 (let : base/book
  [chapter : base/chapter :=
    (chapter<-xml
     xml)
   name : string := (:name chapter)
   origmap : base/chaptermap := (:chaptermap book)
   chgmap  : base/chaptermap :=
    (copy origmap
     name chapter)]
  (copy book
   :chaptermap chgmap))
 :test (test
        (base/book
         :chaptermap
          (base/chaptermap
           :chapter1
            (base/chapter
             :name "chapter1")))
        (book<-book-xmlchapter
         (empty base/book)
         (xml/xml
          :tag "chapter"
          :propmap
           (stringmap
            :name "chapter1"))))
 :doc "Returns an altered book based on xmlchapter.")

(func book<-book-xmlchild : base/book
 [book  : base/book
  child : xml/xml]
 (let : base/book
  [tag : string := (:tag child)]
  (switch : base/book
   tag
   (case "" book)
   (case
    (list
     "reference"
     "summary"
     "titles")
    (copy book
     tag
     (xml/string-first<-xml
      child)))
   (case "chapter"
    (book<-book-xmlchapter
     book
     child))
   (else
    (copy book
     (msg<-error
      :invalidtagfound
      (anymap
       :type base/book
       :tag tag))))))
 :test (test
        (base/book
         :titles "titles")
        (book<-book-xmlchild
         (empty base/book)
         (xml/xml
          :tag "titles"
          :children
           (xml/xmllist
            (xml/xml
             :text "titles")))))
       (test
        (base/book
         :chaptermap
          (base/chaptermap
           :chapter1
            (base/chapter
             :name "chapter1")))
        (book<-book-xmlchild
         (empty base/book)
         (xml/xml
          :tag "chapter"
          :propmap
           (stringmap
            :name "chapter1"))))
 :doc "Returns a modified book based on a given child xml.")

(func book<-xml : base/book
 [xml : xml/xml]
 (book<-xmllist
  (:children xml))
 :test (test
        (base/book
         :name "name1")
        (book<-xml
         (xml/xml
          :children
           (xml/xmllist
            (xml/xml
             :tag "?xml")
            (xml/xml
             :tag "doc"
             :propmap
              (stringmap
               :name "name1"))))))
 :doc "Returns a book from a given top level xml.")

(func book<-xmldoc : base/book
 [xml : xml/xml]
 (let : base/book
  [propmap  : stringmap := (:propmap xml)
   children : xmllist   := (:children xml)
   book : base/book :=
    (book<-book-stringmap
     (empty base/book)
     propmap)]
  (any<-list-start-reduce : base/book
   children
   book
   book<-book-xmlchild))
 :test (test
        (base/book
         :name "name1"
         :image "image1"
         :titles "titles1"
         :reference "reference1"
         :chaptermap
          (base/chaptermap
           :chapter1
            (base/chapter
             :name "chapter1")))
        (book<-xmldoc
         (xml/xml
          :tag "doc"
          :propmap
           (stringmap
            :name "name1"
            :image "image1")
          :children
           (xml/xmllist
            (xml/xml
             :tag "titles"
             :children
              (xml/xmllist
               (xml/xml
                :text "titles1")))
            (xml/xml
             :tag "reference"
             :children
              (xml/xmllist
               (xml/xml
                :text "reference1")))
            (xml/xml
             :tag "chapter"
             :propmap
              (stringmap
               :name "chapter1"))))))
 :doc "Returns a book from a given xml.")

(func book<-xmllist : base/book
 [xmllist : xml/xmllist]
 (any<-list-start-reduce : base/book
  xmllist
  (empty base/book)
  book<-book-xml)
 :test (test
        (base/book
         :name "name1")
        (book<-xmllist
         (xml/xmllist
          (xml/xml
           :tag "?xml")
          (xml/xml
           :tag "doc"
           :propmap
            (stringmap
             :name "name1")))))
 :doc "Returns a book from a given xml.")

(func boolean-write<-book : boolean
 [book : base/book]
 (let : boolean
  [text : string :=
    (string-vxlisp<-book
     book)
   file : fil/file :=
    (file-write<-book
     book)]
  (boolean-write<-file-string
   file
   text))
 :context
 :doc "Returns boolean after writing book as a file.")

(func book-read<-bookname : base/book
 [bookname : string]
 (let : base/book
  [xml : xml/xml :=
    (xml-read<-bookname
     bookname)]
  (book<-xml
   xml))
 :context
 :doc "Returns a book by loading the given Xml filename.")

(func boolean-write<-booknames : boolean
 [booknames : stringlist]
 (let : boolean
  [bools : booleanlist :=
    (list<-list : booleanlist
     booknames
     (fn : boolean
      [bookname : string]
      (let : boolean
       [book : base/book :=
         (book-read<-bookname
          bookname)]
       (boolean-write<-book
        book))))]
  (and bools))
 :context
 :doc "Returns boolean after writing book as a file.")

(func chapter<-chapter-key-value : base/chapter
 [current : base/chapter
  key     : string
  value   : string]
 (switch : base/chapter
  key
  (case "" current)
  (case
   (list
    "name"
    "image")
   (copy current
    key value))
  (else
   (copy current
    (msg<-error
     :invalidproperty
     (anymap
      :type  base/chapter
      :prop  key
      :value value)))))
 :doc "Returns a modified chapter from a key value.")

(func chapter<-chapter-stringmap : base/chapter
 [chapter : base/chapter
  propmap : stringmap]
 (any<-map-start-reduce : base/chapter
  propmap
  chapter
  chapter<-chapter-key-value)
 :test (test
        (base/chapter
         :name "name"
         :image "image")
        (chapter<-chapter-stringmap
         (empty base/chapter)
         (stringmap
          :name "name"
          :image "image")))
 :doc "Returns a new book from a propmap.")

(func chapter<-chapter-xmlchild : base/chapter
 [chapter : base/chapter
  child   : xml/xml]
 (let : base/chapter
  [tag : string := (:tag child)]
  (switch : base/chapter
   tag
   (case "" chapter)
   (case
    (list
     "reference"
     "summary"
     "titles")
    (copy chapter
     tag
     (xml/string-first<-xml
      child)))
   (case "section"
    (chapter<-chapter-xmlsection
     chapter
     child))
   (else
    (copy chapter
     (msg<-error
      :invalidtagfound
      (anymap
       :type base/chapter
       :tag tag))))))
 :test (test
        (base/chapter
         :titles "titles")
        (chapter<-chapter-xmlchild
         (empty base/chapter)
         (xml/xml
          :tag "titles"
          :children
           (xml/xmllist
            (xml/xml
             :text "titles")))))
 :doc "Returns a modified chapter based on a given child Xml.")

(func chapter<-chapter-xmlsection : base/chapter
 [chapter    : base/chapter
  xmlsection : xml/xml]
 (let : base/chapter
  [section : base/section :=
    (section<-xml
     xmlsection)
   name : string := (:name section)
   origmap : base/sectionmap := (:sectionmap chapter)
   chgmap  : base/sectionmap :=
    (copy origmap
     name section)]
  (copy chapter
   :sectionmap chgmap))
 :doc "Return a chapter with new section added to sectionmap")

(func chapter<-xml : base/chapter
 [xml : xml/xml]
 (let : base/chapter
  [propmap : stringmap := (:propmap xml)
   chap : base/chapter :=
    (chapter<-chapter-stringmap
     (empty base/chapter)
     propmap)]
  (any<-list-start-reduce : base/chapter
   (:children xml)
   chap
   chapter<-chapter-xmlchild))
 :test (test
        (base/chapter
         :name "name"
         :image "image"
         :titles "titles"
         :reference "reference"
         :sectionmap
          (base/sectionmap
           :section1
            (base/section
             :name "section1")
           :section2
            (base/section
             :name "section2")))
        (chapter<-xml
         (xml/xml
          :tag "chapter"
          :propmap
           (stringmap
            :name "name"
            :image "image")
          :children
           (xml/xmllist
            (xml/xml
             :tag "titles"
             :children
              (xml/xmllist
               (xml/xml
                :text "titles")))
            (xml/xml
             :tag "reference"
             :children
              (xml/xmllist
               (xml/xml
                :text "reference")))
            (xml/xml
             :tag "section"
             :propmap
              (stringmap
               :name "section1"))
            (xml/xml
             :tag "section"
             :propmap
              (stringmap
               :name "section2"))))))
 :doc "Returns a chapter from a given Xml.")

(func damage<-damage-key-value : base/damage
 [current : base/damage
  key     : string
  value   : string]
 (switch : base/damage
  key
  (case "" current)
  (case
   (list
    "name"
    "image"
    "classification")
   (copy current
    key value))
  (else
   (copy current
    (msg<-error
     :invalidproperty
     (anymap
      :type  base/damage
      :prop  key
      :value value)))))
 :doc "Returns a modified damage from a key value.")

(func damage<-damage-stringmap : base/damage
 [damage  : base/damage
  propmap : stringmap]
 (any<-map-start-reduce : base/damage
  propmap
  damage
  damage<-damage-key-value)
 :test (test
        (base/damage
         :name  "name"
         :image "image")
        (damage<-damage-stringmap
         (empty base/damage)
         (stringmap
          :name  "name"
          :image "image")))
 :doc "Returns a damage from a propmap.")

(func damage<-damage-xmlchild : base/damage
 [damage : base/damage
  child  : xml/xml]
 (let : base/damage
  [tag : string := (:tag child)]
  (switch : base/damage
   tag
   (case "" damage)
   (case
    (list
     "reference"
     "summary"
     "titles")
    (copy damage
     tag
     (xml/string-first<-xml
      child)))
   (else
    (copy damage
     (msg<-error
      :invalidtagfound
      (anymap
       :type base/damage
       :tag tag))))))
 :test (test
        (base/damage
         :titles "titles")
        (damage<-damage-xmlchild
         (empty base/damage)
         (xml/xml
          :tag "titles"
          :children
           (xml/xmllist
            (xml/xml
             :text "titles")))))
 :doc "Returns a modified damage based on a given child Xml.")

(func damage<-xml : base/damage
 [xml : xml/xml]
 (let : base/damage
  [propmap : stringmap := (:propmap xml)
   damage : base/damage :=
    (damage<-damage-stringmap
     (empty base/damage)
     propmap)]
  (any<-list-start-reduce : base/damage
   (:children xml)
   damage
   damage<-damage-xmlchild))
 :doc "Returns a damage from a given xml.")

(func file-read<-bookname : fil/file
 [bookname : string]
 (fil/file
  :path "resources/books"
  :name (string
         bookname
         ".xml"))
 :doc "Returns a file from a bookname.")

(func file-write<-book : fil/file
 [book : base/book]
 (let : fil/file
  [name : string := (:name book)
   bookname : string :=
    (string-writename<-string
     name)]
  (fil/file
   :path "resources/books"
   :name (string
          bookname
          ".vxlisp")))
 :doc "Returns a file with string from book")

(func item<-item-key-value : base/item
 [current : base/item
  key     : string
  value   : string]
 (switch : base/item
  key
  (case "" current)
  (case
   (list
    "name"
    "image"
    "classification"
    "crew"
    "energy"
    "explosive"
    "height"
    "length"
    "mass"
    "modifiers"
    "muzzlevelocity"
    "range"
    "rof"
    "rounds"
    "speedair"
    "speedland"
    "speedspace"
    "speedwater"
    "width")
   (copy current
    key value))
  (else
   (copy current
    (msg<-error
     :invalidproperty
     (anymap
      :type  base/item
      :prop  key
      :value value)))))
 :doc "Returns a modified item from a key value.")

(func item<-item-stringmap : base/item
 [item    : base/item
  propmap : stringmap]
 (any<-map-start-reduce : base/item
  propmap
  item
  item<-item-key-value)
 :doc "Returns a new item from a propmap.")

(func item<-item-xmlchild : base/item
 [item  : base/item
  child : xml/xml]
 (let : base/item
  [tag : string := (:tag child)]
  (switch : base/item
   tag
   (case "" item)
   (case
    (list
     "reference"
     "summary"
     "titles")
    (copy item
     tag
     (xml/string-first<-xml
      child)))
   (else
    (copy item
     (msg<-error
      :invalidtagfound
      (anymap
       :type base/item
       :tag tag))))))
 :doc "Returns a modified item based on a given child xml.")

(func item<-xml : base/item
 [xml : xml/xml]
 (let : base/item
  [propmap : stringmap := (:propmap xml)
   item : base/item :=
    (item<-item-stringmap
     (empty base/item)
     propmap)]
  (any<-list-start-reduce : base/item
   (:children xml)
   item
   item<-item-xmlchild))
 :doc "Returns a item from a given xml.")

(func place<-place-key-value : base/place
 [current : base/place
  key     : string
  value   : string]
 (switch : base/place
  key
  (case "" current)
  (case
   (list
    "name"
    "image")
   (copy current
    key value))
  (else
   (copy current
    (msg<-error
     :invalidproperty
     (anymap
      :type  base/place
      :prop  key
      :value value)))))
 :doc "Returns a modified place from a key value.")

(func place<-place-stringmap : base/place
 [place : base/place
  propmap  : stringmap]
 (any<-map-start-reduce : base/place
  propmap
  place
  place<-place-key-value)
 :doc "Returns a place from a propmap.")

(func place<-place-xmlchild : base/place
 [place : base/place
  child    : xml/xml]
 (let : base/place
  [tag : string := (:tag child)]
  (switch : base/place
   tag
   (case "" place)
   (case
    (list
     "reference"
     "summary"
     "titles")
    (copy place
     tag
     (xml/string-first<-xml
      child)))
   (else
    (copy place
     (msg<-error
      :invalidtagfound
      (anymap
       :type base/place
       :tag tag))))))
 :doc "Returns a modified place based on a given child Xml.")

(func place<-xml : base/place
 [xml : xml/xml]
 (let : base/place
  [propmap  : stringmap := (:propmap xml)
   place : base/place :=
    (place<-place-stringmap
     (empty base/place)
     propmap)]
  (any<-list-start-reduce : base/place
   (:children xml)
   place
   place<-place-xmlchild))
 :doc "Returns a place from a given xml.")

(func modifier<-modifier-key-value : base/modifier
 [current : base/modifier
  key     : string
  value   : string]
 (switch : base/modifier
  key
  (case "" current)
  (case
   (list
    "name"
    "image")
   (copy current
    key value))
  (else
   (copy current
    (msg<-error
     :invalidproperty
     (anymap
      :type  base/modifier
      :prop  key
      :value value)))))
 :doc "Returns a modified modifier from a key value.")

(func modifier<-modifier-stringmap : base/modifier
 [modifier : base/modifier
  propmap  : stringmap]
 (any<-map-start-reduce : base/modifier
  propmap
  modifier
  modifier<-modifier-key-value)
 :doc "Returns a modifier from a propmap.")

(func modifier<-modifier-xmlchild : base/modifier
 [modifier : base/modifier
  child    : xml/xml]
 (let : base/modifier
  [tag : string := (:tag child)]
  (switch : base/modifier
   tag
   (case "" modifier)
   (case
    (list
     "reference"
     "summary"
     "titles")
    (copy modifier
     tag
     (xml/string-first<-xml
      child)))
   (else
    (copy modifier
     (msg<-error
      :invalidtagfound
      (anymap
       :type base/modifier
       :tag tag))))))
 :doc "Returns a modified modifier based on a given child xml.")

(func modifier<-xml : base/modifier
 [xml : xml/xml]
 (let : base/modifier
  [propmap : stringmap  := (:propmap xml)
   modifier : base/modifier :=
    (modifier<-modifier-stringmap
     (empty base/modifier)
     propmap)]
  (any<-list-start-reduce : base/modifier
   (:children xml)
   modifier
   modifier<-modifier-xmlchild))
 :doc "Returns a modifier from a given xml.")

(func power<-power-key-value : base/power
 [current : base/power
  key     : string
  value   : string]
 (switch : base/power
  key
  (case "" current)
  (case
   (list
    "name"
    "image"
    "stat")
   (copy current
    key value))
  (else
   (copy current
    (msg<-error
     :invalidproperty
     (anymap
      :type  base/power
      :prop  key
      :value value)))))
 :doc "Returns a modified power from a key value.")

(func power<-power-stringmap : base/power
 [power   : base/power
  propmap : stringmap]
 (any<-map-start-reduce : base/power
  propmap
  power
  power<-power-key-value)
 :test (test
        (base/power
         :name "name"
         :image "image")
        (power<-power-stringmap
         (empty base/power)
         (stringmap
          :name "name"
          :image "image")))
 :doc "Returns a new power from a propmap.")

(func power<-power-xmlchild : base/power
 [power : base/power
  child : xml/xml]
 (let : base/power
  [tag : string := (:tag child)]
  (switch : base/power
   tag
   (case "" power)
   (case
    (list
     "reference"
     "summary"
     "titles")
    (copy power
     tag
     (xml/string-first<-xml
      child)))
   (case "ability"
    (power<-power-xmlability
     power
     child))
   (case "specialty"
    (power<-power-xmlspecialty
     power
     child))
   (else
    (copy power
     (msg<-error
      :invalidtagfound
      (anymap
       :type base/power
       :tag tag))))))
 :test (test
        (base/power
         :titles "titles")
        (power<-power-xmlchild
         (empty base/power)
         (xml/xml
          :tag "titles"
          :children
           (xml/xmllist
            (xml/xml
             :text "titles")))))
 :doc "Returns a modified power based on a given child xml.")

(func power<-xml : base/power
 [xml : xml/xml]
 (let : base/power
  [propmap  : stringmap := (:propmap xml)
   children : xmllist   := (:children xml)
   power : base/power :=
    (power<-power-stringmap
     (empty base/power)
     propmap)]
  (any<-list-start-reduce : base/power
   children
   power
   power<-power-xmlchild))
 :test (test
        (base/power
         :name "name"
         :image "image"
         :titles "titles"
         :reference "reference"
         :abilitymap
          (base/abilitymap
           :ability1
            (base/ability
             :name "ability1"))
         :specialtymap
          (base/specialtymap
           :specialty1
            (base/specialty
             :name "specialty1")))
        (power<-xml
         (xml/xml
          :tag "power"
          :propmap
           (stringmap
            :name "name"
            :image "image")
          :children
           (xml/xmllist
            (xml/xml
             :tag "titles"
             :children
              (xml/xmllist
               (xml/xml
                :text "titles")))
            (xml/xml
             :tag "reference"
             :children
              (xml/xmllist
               (xml/xml
                :text "reference")))
            (xml/xml
             :tag "ability"
             :propmap
              (stringmap
               :name "ability1"))
            (xml/xml
             :tag "specialty"
             :propmap
              (stringmap
               :name "specialty1"))))))
 :doc "Returns a power from a given Xml.")

(func power<-power-xmlability : base/power
 [power      : base/power
  xmlability : xml/xml]
 (let : base/power
  [ability : base/ability :=
    (ability<-xml
     xmlability)
   name : string := (:name ability)
   origmap : base/abilitymap := (:abilitymap power)
   chgmap  : base/abilitymap :=
    (copy origmap
     name ability)]
  (copy power
   :abilitymap chgmap))
 :doc "Return a power with new ability added to abilitymap")

(func power<-power-xmlspecialty : base/power
 [power        : base/power
  xmlspecialty : xml/xml]
 (let : base/power
  [specialty : base/specialty :=
    (specialty<-xml
     xmlspecialty)
   name : string := (:name specialty)
   origmap : base/specialtymap := (:specialtymap power)
   chgmap  : base/specialtymap :=
    (copy origmap
     name specialty)]
  (copy power
   :specialtymap chgmap))
 :doc "Return a power with new specialty added to specialtymap")

(func rule<-rule-key-value : base/rule
 [current : base/rule
  key     : string
  value   : string]
 (switch : base/rule
  key
  (case "" current)
  (case
   (list
    "name"
    "image"
    "classification")
   (copy current
    key value))
  (else
   (copy current
    (msg<-error
     :invalidproperty
     (anymap
      :type  base/rule
      :prop  key
      :value value)))))
 :doc "Returns a modified rule from a key value.")

(func rule<-rule-stringmap : base/rule
 [rule    : base/rule
  propmap : stringmap]
 (any<-map-start-reduce : base/rule
  propmap
  rule
  rule<-rule-key-value)
 :test (test
        (base/rule
         :name  "name"
         :image "image")
        (rule<-rule-stringmap
         (empty base/rule)
         (stringmap
          :name  "name"
          :image "image")))
 :doc "Returns a rule from a propmap.")

(func rule<-rule-xmlchild : base/rule
 [rule  : base/rule
  child : xml/xml]
 (let : base/rule
  [tag : string := (:tag child)]
  (switch : base/rule
   tag
   (case "" rule)
   (case
    (list
     "reference"
     "summary"
     "titles"
     "classification")
    (copy rule
     tag
     (xml/string-first<-xml
      child)))
   (else
    (copy rule
     (msg<-error
      :invalidtagfound
      (anymap
       :type base/rule
       :tag tag))))))
 :test (test
        (base/rule
         :titles "titles")
        (rule<-rule-xmlchild
         (empty base/rule)
         (xml/xml
          :tag "titles"
          :children
           (xml/xmllist
            (xml/xml
             :text "titles")))))
 :doc "Returns a modified rule based on a given child Xml.")

(func rule<-xml : base/rule
 [xml : xml/xml]
 (let : base/rule
  [propmap : stringmap := (:propmap xml)
   rule : base/rule :=
    (rule<-rule-stringmap
     (empty base/rule)
     propmap)]
  (any<-list-start-reduce : base/rule
   (:children xml)
   rule
   rule<-rule-xmlchild))
 :doc "Returns a rule from a given xml.")

(func scenario<-scenario-key-value : base/scenario
 [current : base/scenario
  key     : string
  value   : string]
 (switch : base/scenario
  key
  (case "" current)
  (case
   (list
    "name"
    "image")
   (copy current
    key value))
  (else
   (copy current
    (msg<-error
     :invalidproperty
     (anymap
      :type  base/scenario
      :prop  key
      :value value)))))
 :doc "Returns a modified scenario from a key value.")

(func scenario<-scenario-stringmap : base/scenario
 [scenario : base/scenario
  propmap  : stringmap]
 (any<-map-start-reduce : base/scenario
  propmap
  scenario
  scenario<-scenario-key-value)
 :doc "Returns a scenario from a propmap.")

(func scenario<-scenario-xmlchild : base/scenario
 [scenario : base/scenario
  child    : xml/xml]
 (let : base/scenario
  [tag : string := (:tag child)]
  (switch : base/scenario
   tag
   (case "" scenario)
   (case
    (list
     "reference"
     "summary"
     "titles")
    (copy scenario
     tag
     (xml/string-first<-xml
      child)))
   (case "team"
    (scenario<-scenario-xmlteam
     scenario
     child))
   (else
    (copy scenario
     (msg<-error
      :invalidtagfound
      (anymap
       :type base/scenario
       :tag tag))))))
 :doc "Returns a modified scenario based on a given child Xml.")

(func scenario<-scenario-xmlteam : base/scenario
 [scenario : base/scenario
  xmlteam  : xml/xml]
 (let : base/scenario
  [current : base/team :=
    (team<-xml
     xmlteam)
   name : string := (:name current)
   origmap : base/teammap := (:teammap scenario)
   chgmap  : base/teammap :=
    (copy origmap
     name current)]
  (copy scenario
   :teammap chgmap))
 :doc "Return a scenario with new team added to teammap")

(func scenario<-xml : base/scenario
 [xml : xml/xml]
 (let : base/scenario
  [propmap : stringmap := (:propmap xml)
   scenario : base/scenario :=
    (scenario<-scenario-stringmap
     (empty base/scenario)
     propmap)]
  (any<-list-start-reduce : base/scenario
   (:children xml)
   scenario
   scenario<-scenario-xmlchild))
 :test (test
        (base/scenario
         :name "name"
         :image "image"
         :titles "titles"
         :reference "reference")
        (scenario<-xml
         (xml/xml
          :tag "scenario"
          :propmap
           (stringmap
            :name "name"
            :image "image")
          :children
           (xml/xmllist
            (xml/xml
             :tag "titles"
             :children
              (xml/xmllist
               (xml/xml
                :text "titles")))
            (xml/xml
             :tag "reference"
             :children
              (xml/xmllist
               (xml/xml
                :text "reference")))))))
 :doc "Returns a scenario from a given xml.")

(func section<-section-key-value : base/section
 [current : base/section
  key     : string
  value   : string]
 (switch : base/section
  key
  (case "" current)
  (case
   (list
    "name"
    "image")
   (copy current
    key value))
  (else
   (copy current
    (msg<-error
     :invalidproperty
     (anymap
      :type  base/section
      :prop  key
      :value value)))))
 :doc "Returns a modified section from a key value.")

(func section<-section-stringmap : base/section
 [section : base/section
  propmap : stringmap]
 (any<-map-start-reduce : base/section
  propmap
  section
  section<-section-key-value)
 :doc "Returns a new book from a propmap.")

(func section<-section-xmlchild : base/section
 [section : base/section
  child   : xml/xml]
 (let : base/section
  [tag : string := (:tag child)]
  (switch : base/section
   tag
   (case "" section)
   (case
    (list
     "reference"
     "summary"
     "titles")
    (copy section
     tag
     (xml/string-first<-xml
      child)))
   (case "damage"
    (section<-section-xmldamage
     section
     child))
   (case "item"
    (section<-section-xmlitem
     section
     child))
   (case "modifier"
    (section<-section-xmlmodifier
     section
     child))
   (case "place"
    (section<-section-xmlplace
     section
     child))
   (case "power"
    (section<-section-xmlpower
     section
     child))
   (case "rule"
    (section<-section-xmlrule
     section
     child))
   (case "scenario"
    (section<-section-xmlscenario
     section
     child))
   (case "section"
    (section<-section-xmlsection
     section
     child))
   (case "skill"
    (section<-section-xmlskill
     section
     child))
   (case "terrain"
    (section<-section-xmlterrain
     section
     child))
   (case "unit"
    (section<-section-xmlunit
     section
     child))
   (else
    (copy section
     (msg<-error
      :invalidtagfound
      (anymap
       :type base/section
       :tag tag))))))
 :doc "Returns a modified section based on a given child Xml.")

(func section<-section-xmldamage : base/section
 [section   : base/section
  xmldamage : xml/xml]
 (let : base/section
  [current : base/damage :=
    (damage<-xml
     xmldamage)
   name : string := (:name current)
   origmap : base/damagemap := (:damagemap section)
   chgmap  : base/damagemap :=
    (copy origmap
     name current)]
  (copy section
   :damagemap chgmap))
 :doc "Return a section with new damage added to damagemap")

(func section<-section-xmlitem : base/section
 [section : base/section
  xmlitem : xml/xml]
 (let : base/section
  [item : base/item :=
    (item<-xml
     xmlitem)
   name : string := (:name item)
   origmap : base/itemmap := (:itemmap section)
   chgmap  : base/itemmap :=
    (copy origmap
     name item)]
  (copy section
   :itemmap chgmap))
 :doc "Return a section with new item added to itemmap")

(func section<-section-xmlplace : base/section
 [section     : base/section
  xmlplace : xml/xml]
 (let : base/section
  [place : base/place :=
    (place<-xml
     xmlplace)
   name : string := (:name place)
   origmap : base/placemap := (:placemap section)
   chgmap  : base/placemap :=
    (copy origmap
     name place)]
  (copy section
   :placemap chgmap))
 :doc "Return a section with new place added to placemap")

(func section<-section-xmlmodifier : base/section
 [section     : base/section
  xmlmodifier : xml/xml]
 (let : base/section
  [modifier : base/modifier :=
    (modifier<-xml
     xmlmodifier)
   name : string := (:name modifier)
   origmap : base/modifiermap := (:modifiermap section)
   chgmap  : base/modifiermap :=
    (copy origmap
     name modifier)]
  (copy section
   :modifiermap chgmap))
 :doc "Return a section with new modifier added to modifiermap")

(func section<-section-xmlpower : base/section
 [section  : base/section
  xmlpower : xml/xml]
 (let : base/section
  [power : base/power :=
    (power<-xml
     xmlpower)
   name : string := (:name power)
   origmap : base/powermap := (:powermap section)
   chgmap  : base/powermap :=
    (copy origmap
     name power)]
  (copy section
   :powermap chgmap))
 :doc "Return a section with new power added to powermap")

(func section<-section-xmlrule : base/section
 [section : base/section
  xmlrule : xml/xml]
 (let : base/section
  [rule : base/rule :=
    (rule<-xml
     xmlrule)
   name : string := (:name rule)
   origmap : base/rulemap := (:rulemap section)
   chgmap  : base/rulemap :=
    (copy origmap
     name rule)]
  (copy section
   :rulemap chgmap))
 :doc "Return a section with new rule added to rulemap")

(func section<-section-xmlscenario : base/section
 [section     : base/section
  xmlscenario : xml/xml]
 (let : base/section
  [scenario : base/scenario :=
    (scenario<-xml
     xmlscenario)
   name : string := (:name scenario)
   origmap : base/scenariomap := (:scenariomap section)
   chgmap  : base/scenariomap :=
    (copy origmap
     name scenario)]
  (copy section
   :scenariomap chgmap))
 :doc "Return a section with new scenario added to scenariomap")

(func section<-section-xmlsection : base/section
 [section    : base/section
  xmlsection : xml/xml]
 (let : base/section
  [subsect : base/section :=
    (section<-xml
     xmlsection)
   name : string := (:name subsect)
   origmap : base/sectionmap := (:sectionmap section)
   chgmap  : base/sectionmap :=
    (copy origmap
     name subsect)]
  (copy section
   :sectionmap chgmap))
 :doc "Return a section with new section added to sectionmap")

(func section<-section-xmlskill : base/section
 [section  : base/section
  xmlskill : xml/xml]
 (let : base/section
  [skill : base/skill :=
    (skill<-xml
     xmlskill)
   name : string := (:name skill)
   origmap : base/skillmap := (:skillmap section)
   chgmap  : base/skillmap :=
    (copy origmap
     name skill)]
  (copy section
   :skillmap chgmap))
 :doc "Return a section with new skill added to skillmap")

(func section<-section-xmlterrain : base/section
 [section    : base/section
  xmlterrain : xml/xml]
 (let : base/section
  [current : base/terrain :=
    (terrain<-xml
     xmlterrain)
   name : string := (:name current)
   origmap : base/terrainmap :=
    (:terrainmap section)
   chgmap  : base/terrainmap :=
    (copy origmap
     name current)]
  (copy section
   :terrainmap chgmap))
 :doc "Return a section with new terrain added to terrainmap")

(func section<-section-xmlunit : base/section
 [section : base/section
  xmlunit : xml/xml]
 (let : base/section
  [unit : base/unit :=
    (unit<-xml
     xmlunit)
   name : string := (:name unit)
   origmap : base/unitmap := (:unitmap section)
   chgmap  : base/unitmap :=
    (copy origmap
     name unit)]
  (copy section
   :unitmap chgmap))
 :doc "Return a section with new unit added to unitmap")

(func section<-xml : base/section
 [xml : xml/xml]
 (let : base/section
  [propmap : stringmap  := (:propmap  xml)
   children : xml/xmllist := (:children xml)
   section : base/section :=
    (section<-section-stringmap
     (empty base/section)
     propmap)]
  (any<-list-start-reduce : base/section
   children
   section
   section<-section-xmlchild))
 :test (test
        (base/section
         :name "name"
         :image "image"
         :titles "titles"
         :reference "reference"
         :powermap
          (base/powermap
           :power1
            (base/power
             :name "power1"))
         :scenariomap
          (base/scenariomap
           :scenario1
            (base/scenario
             :name "scenario1"))
         :sectionmap
          (base/sectionmap
           :section1
            (base/section
             :name "section1"))
         :skillmap
          (base/skillmap
           :skill1
            (base/skill
             :name "skill1")))
        (section<-xml
         (xml/xml
          :tag "section"
          :propmap
           (stringmap
            :name "name"
            :image "image")
          :children
           (xml/xmllist
            (xml/xml
             :tag "titles"
             :children
              (xml/xmllist
               (xml/xml
                :text "titles")))
            (xml/xml
             :tag "reference"
             :children
              (xml/xmllist
               (xml/xml
                :text "reference")))
            (xml/xml
             :tag "power"
             :propmap
              (stringmap
               :name "power1"))
            (xml/xml
             :tag "scenario"
             :propmap
              (stringmap
               :name "scenario1"))
            (xml/xml
             :tag "section"
             :propmap
              (stringmap
               :name "section1"))
            (xml/xml
             :tag "skill"
             :propmap
              (stringmap
               :name "skill1"))))))
 :doc "Returns a section from a given Xml.")

(func skill<-skill-key-value : base/skill
 [current : base/skill
  key     : string
  value   : string]
 (switch : base/skill
  key
  (case "" current)
  (case
   (list
    "name"
    "image"
    "stat")
   (copy current
    key value))
  (else
   (copy current
    (msg<-error
     :invalidproperty
     (anymap
      :type  base/skill
      :prop  key
      :value value)))))
 :doc "Returns a modified skill from a key value.")

(func skill<-skill-stringmap : base/skill
 [skill : base/skill
  propmap : stringmap]
 (any<-map-start-reduce : base/skill
  propmap
  skill
  skill<-skill-key-value)
 :doc "Returns a new skill from a propmap.")

(func skill<-skill-xmlchild : base/skill
 [skill : base/skill
  child : xml/xml]
 (let : base/skill
  [tag : string := (:tag child)]
  (switch : base/skill
   tag
   (case "" skill)
   (case
    (list
     "reference"
     "summary"
     "titles")
    (copy skill
     tag
     (xml/string-first<-xml
     child)))
   (case "ability"
    (skill<-skill-xmlability
     skill
     child))
   (case "specialty"
    (skill<-skill-xmlspecialty
     skill
     child))
   (else
    (copy skill
     (msg<-error
      :invalidtagfound
      (anymap
       :type base/skill
       :tag tag))))))
 :test (test
        (base/skill
         :titles "titles")
        (skill<-skill-xmlchild
         (empty base/skill)
         (xml/xml
          :tag "titles"
          :children
           (xml/xmllist
            (xml/xml
             :text "titles")))))
 :doc "Returns a modified skill based on a given child Xml.")

(func skill<-skill-xmlability : base/skill
 [skill      : base/skill
  xmlability : xml/xml]
 (let : base/skill
  [ability : base/ability :=
    (ability<-xml
     xmlability)
   name : string := (:name ability)
   origmap : base/abilitymap := (:abilitymap skill)
   chgmap  : base/abilitymap :=
    (copy origmap
     name ability)]
  (copy skill
   :abilitymap chgmap))
 :doc "Return a skill with new ability added to abilitymap")

(func skill<-skill-xmlspecialty : base/skill
 [skill        : base/skill
  xmlspecialty : xml/xml]
 (let : base/skill
  [specialty : base/specialty :=
    (specialty<-xml
     xmlspecialty)
   name : string := (:name specialty)
   origmap : base/specialtymap := (:specialtymap skill)
   chgmap  : base/specialtymap :=
    (copy origmap
     name specialty)]
  (copy skill
   :specialtymap chgmap))
 :doc "Return a skill with new specialty added to specialtymap")

(func skill<-xml : base/skill
 [xml : xml/xml]
 (let : base/skill
  [propmap : stringmap := (:propmap xml)
   skill : base/skill :=
    (skill<-skill-stringmap
     (empty base/skill)
     propmap)]
  (any<-list-start-reduce : base/skill
   (:children xml)
   skill
   skill<-skill-xmlchild))
 :test (test
        (base/skill
         :name "name"
         :image "image"
         :titles "titles"
         :reference "reference"
         :abilitymap
          (base/abilitymap
           :ability1
            (base/ability
             :name "ability1"))
         :specialtymap
          (base/specialtymap
           :specialty1
            (base/specialty
             :name "specialty1")))
        (skill<-xml
         (xml/xml
          :tag "skill"
          :propmap
           (stringmap
            :name "name"
            :image "image")
          :children
           (xml/xmllist
            (xml/xml
             :tag "titles"
             :children
              (xml/xmllist
               (xml/xml
                :text "titles")))
            (xml/xml
             :tag "reference"
             :children
              (xml/xmllist
               (xml/xml
                :text "reference")))
            (xml/xml
             :tag "ability"
             :propmap
              (stringmap
               :name "ability1"))
            (xml/xml
             :tag "specialty"
             :propmap
              (stringmap
               :name "specialty1"))))))
 :doc "Returns a skill from a given xml.")

(func specialty<-specialty-key-value : base/specialty
 [current : base/specialty
  key     : string
  value   : string]
 (switch : base/specialty
  key
  (case "" current)
  (case
   (list
    "name"
    "image")
   (copy current
    key value))
  (else
   (copy current
    (msg<-error
     :invalidproperty
     (anymap
      :type  base/specialty
      :prop  key
      :value value)))))
 :doc "Returns a modified specialty from a key value.")

(func specialty<-specialty-stringmap : base/specialty
 [specialty : base/specialty
  propmap   : stringmap]
 (any<-map-start-reduce : base/specialty
  propmap
  specialty
  specialty<-specialty-key-value)
 :test (test
        (base/specialty
         :name "name"
         :image "image")
        (specialty<-specialty-stringmap
         (empty base/specialty)
         (stringmap
          :name "name"
          :image "image")))
 :doc "Returns a new specialty from a propmap.")

(func specialty<-specialty-xmlchild : base/specialty
 [specialty : base/specialty
  child     : xml/xml]
 (let : base/specialty
  [tag : string := (:tag child)]
  (switch : base/specialty
   tag
   (case "" specialty)
   (case
    (list
     "reference"
     "summary"
     "titles")
    (copy specialty
     tag
     (xml/string-first<-xml
      child)))
   (else
    (copy specialty
     (msg<-error
      :invalidtagfound
      (anymap
       :type base/specialty
       :tag tag))))))
 :test (test
        (base/specialty
         :titles "titles")
        (specialty<-specialty-xmlchild
         (empty base/specialty)
         (xml/xml
          :tag "titles"
          :children
           (xml/xmllist
            (xml/xml
             :text "titles")))))
 :doc "Returns a modified specialty based on a given child xml.")

(func specialty<-xml : base/specialty
 [xml : xml/xml]
 (let : base/specialty
  [propmap : stringmap := (:propmap xml)
   spc : base/specialty :=
    (specialty<-specialty-stringmap
     (empty base/specialty)
     propmap)]
  (any<-list-start-reduce : base/specialty
   (:children xml)
   spc
   specialty<-specialty-xmlchild))
 :test (test
        (base/specialty
         :name "name"
         :image "image"
         :titles "titles"
         :reference "reference")
        (specialty<-xml
         (xml/xml
          :tag "specialty"
          :propmap
           (stringmap
            :name "name"
            :image "image")
          :children
           (xml/xmllist
            (xml/xml
             :tag "titles"
             :children
              (xml/xmllist
               (xml/xml
                :text "titles")))
            (xml/xml
             :tag "reference"
             :children
              (xml/xmllist
               (xml/xml
                :text "reference")))))))
 :doc "Returns a specialty from a given xml.")

(func string-read<-bookname : string
 [bookname : string]
 (string-read<-file
  (file-read<-bookname
   bookname))
 :context
 :doc "Returns text from a file with bookname.")

(func string-vxlisp<-chapter : string
 [chapter : base/chapter]
 (let : string
  [name : string := (:name chapter)
   chnm : string :=
    (string-writename<-string
     name)
   text : string :=
    (string<-any-indent
     chapter 1 false)]
   (string
    "(func chapter_"
    chnm
    " : base/chapter\n"
    text
    ")\n"))
 :doc "Returns a vxlisp string from a chapter.")

(func string-vxlisp<-chaptermap : string
 [chaptermap : base/chaptermap]
 (let : string
  [chapters : base/chapterlist :=
    (list<-map : chapterlist
     chaptermap
     (fn : chapter
      [key : string
       val : base/chapter]
      val))
   schapters : stringlist :=
    (list<-list : stringlist
     chapters
     (fn : string
      [chapt : base/chapter]
      (let : string
       [name : string :=
         (base/name<-chapter
          chapt)
        schnm : string :=
         (string-writename<-string
          name)
        text : string :=
         (string<-any-indent
          chapt 1 true)]
        (string
         "\n(func chapter_"
         schnm
         " : base/chapter\n "
         text
         ")"))))]
   (string<-stringlist-join
    schapters
    newline))
 :doc "Returns a vxlisp string from a chaptermap.")

(func string-vxlisp-header<-chaptermap : string
 [chaptermap : base/chaptermap]
 (let : string
  [chapters : stringlist :=
   (list<-map : stringlist
    chaptermap
    (fn : string
     [key : string
      val : base/chapter]
     (string
      newline
      "    "
      quote
      key
      quote
      " (chapter_"
      (string-writename<-string
       key)
      ")")))]
   (string<-stringlist-join
    chapters
    ""))
 :doc "Returns a vxlisp string from a chaptermap.")

(func string-vxlisp<-book : string
 [book : base/book]
 (let : string
  [name : string := (:name book)
   chaptermap : base/chaptermap :=
    (:chaptermap book)
   image : string := (:image book)
   reference : string := (:reference book)
   summary   : string := (:summary book)
   titles    : string := (:titles book)
   schaptermap : string :=
    (string-vxlisp-header<-chaptermap
     chaptermap)
   schapters : string :=
    (string-vxlisp<-chaptermap
     chaptermap)
   simage : string :=
    (switch : string
     image
     (case "" "")
     (else
      (string
       "\n  :image "
       (string<-any image))))
   sreference : string :=
    (switch : string
     reference
     (case "" "")
     (else
      (string
       "\n  :reference "
       (string<-any reference))))
   ssummary : string :=
    (switch : string
     summary
     (case "" "")
     (else
      (string
       "\n  :summary "
       (string<-any summary))))
   stitles : string :=
    (switch : string
     titles
     (case "" "")
     (else
      (string
       "\n  :titles "
       (string<-any titles))))
   bookname : string :=
    (string-writename<-string
     name)]
   (string
    "(package nx/tactics/books/"
    bookname
    "\n :libs (lib base :path nx/tactics/base))"
    "\n"
    "\n(func tacticsbook : base/book"
    "\n (base/book"
    "\n  :name "
    (string<-any name)
    simage
    stitles
    sreference
    ssummary
    "\n  :chaptermap"
    "\n   (base/chaptermap"
    schaptermap
    "\n   ))"
    ")\n"
    schapters))
 :doc "Returns a vxlisp string from a book.")

(func string-writename<-string : string
 [name : string]
 (let : string
  [lower : string :=
    (typ/string-lowercase
     name)
   space : string :=
    (string<-string-find-replace
     lower " " "_")
   comma : string :=
    (string<-string-find-replace
     space "," "")
   apos  : string :=
    (string<-string-find-replace
     comma "'" "")
   slash : string :=
    (string<-string-find-replace
     apos "/" "_")]
  slash)
 :doc "Returns the write filename from a book")

(func team<-team-key-value : base/team
 [current : base/team
  key     : string
  value   : string]
 (switch : base/team
  key
  (case "" current)
  (case
   (list
    "name"
    "image")
   (copy current
    key value))
  (else
   (copy current
    (msg<-error
     :invalidproperty
     (anymap
      :type  base/team
      :prop  key
      :value value)))))
 :doc "Returns a modified team from a key value.")

(func team<-team-stringmap : base/team
 [team     : base/team
  propmap  : stringmap]
 (any<-map-start-reduce : base/team
  propmap
  team
  team<-team-key-value)
 :doc "Returns a team from a propmap.")

(func team<-team-xmlchild : base/team
 [team  : base/team
  child : xml/xml]
 (let : base/team
  [tag : string := (:tag child)]
  (switch : base/team
   tag
   (case "" team)
   (case
    (list
     "reference"
     "summary"
     "titles"
     "completevictory"
     "deploy"
     "forces"
     "partialvictory")
    (copy team
     tag
     (xml/string-first<-xml
      child)))
   (else
    (copy team
     (msg<-error
      :invalidtagfound
      (anymap
       :type base/team
       :tag tag))))))
 :doc "Returns a modified team based on a given child xml.")

(func team<-xml : base/team
 [xml : xml/xml]
 (let : base/team
  [propmap : stringmap := (:propmap xml)
   team : base/team :=
    (team<-team-stringmap
     (empty base/team)
     propmap)]
  (any<-list-start-reduce : base/team
   (:children xml)
   team
   team<-team-xmlchild))
 :doc "Returns a team from a given xml.")

(func terrain<-terrain-key-value : base/terrain
 [current : base/terrain
  key     : string
  value   : string]
 (switch : base/terrain
  key
  (case "" current)
  (case
   (list
    "name"
    "image")
   (copy current
    key value))
  (else
   (copy current
    (msg<-error
     :invalidproperty
     (anymap
      :type  base/terrain
      :prop  key
      :value value)))))
 :doc "Returns a modified terrain from a key value.")

(func terrain<-terrain-stringmap : base/terrain
 [terrain : base/terrain
  propmap : stringmap]
 (any<-map-start-reduce : base/terrain
  propmap
  terrain
  terrain<-terrain-key-value)
 :test (test
        (base/terrain
         :name  "name"
         :image "image")
        (terrain<-terrain-stringmap
         (empty base/terrain)
         (stringmap
          :name  "name"
          :image "image")))
 :doc "Returns a terrain from a propmap.")

(func terrain<-terrain-xmlchild : base/terrain
 [terrain : base/terrain
  child   : xml/xml]
 (let : base/terrain
  [tag : string := (:tag child)]
  (switch : base/terrain
   tag
   (case "" terrain)
   (case
    (list
     "reference"
     "summary"
     "titles"
     "classification")
    (copy terrain
     tag
     (xml/string-first<-xml
      child)))
   (else
    (copy terrain
     (msg<-error
      :invalidtagfound
      (anymap
       :type base/terrain
       :tag tag))))))
 :test (test
        (base/terrain
         :titles "titles")
        (terrain<-terrain-xmlchild
         (empty base/terrain)
         (xml/xml
          :tag "titles"
          :children
           (xml/xmllist
            (xml/xml
             :text "titles")))))
 :doc "Returns a modified terrain based on a given child Xml.")

(func terrain<-xml : base/terrain
 [xml : xml/xml]
 (let : base/terrain
  [propmap : stringmap := (:propmap xml)
   terrain : base/terrain :=
    (terrain<-terrain-stringmap
     (empty base/terrain)
     propmap)]
  (any<-list-start-reduce : base/terrain
   (:children xml)
   terrain
   terrain<-terrain-xmlchild))
 :doc "Returns a terrain from a given xml.")

(func unit<-unit-key-value : base/unit
 [current : base/unit
  key     : string
  value   : string]
 (switch : base/unit
  key
  (case "" current)
  (case
   (list
    "name"
    "image"
    "classification"
    "crew"
    "body"
    "height"
    "length"
    "mass"
    "mind"
    "range"
    "speed"
    "speedair"
    "speedland"
    "speedspace"
    "speedwater"
    "width"
    "will")
   (copy current
    key value))
  (else
   (copy current
    (msg<-error
     :invalidproperty
     (anymap
      :type  base/unit
      :prop  key
      :value value)))))
 :doc "Returns a modified unit from a key value.")

(func unit<-unit-stringmap : base/unit
 [unit    : base/unit
  propmap : stringmap]
 (any<-map-start-reduce
  propmap
  unit
  unit<-unit-key-value)
 :test (test
        (base/unit
         :name "name"
         :image "image")
        (unit<-unit-stringmap
         (empty base/unit)
         (stringmap
          :name "name"
          :image "image")))
 :doc "Returns a new unit from a propmap.")

(func unit<-unit-xmlchild : base/unit
 [unit  : base/unit
  child : xml/xml]
 (let : base/unit
  [tag : string := (:tag child)]
  (switch : base/unit
   tag
   (case "" unit)
   (case
    (list
     "reference"
     "summary"
     "titles")
    (copy unit
     tag
     (xml/string-first<-xml
     child)))
   (case "power"
    (unit<-unit-xmlpower
     unit
     child))
   (case "skill"
    (unit<-unit-xmlskill
     unit
     child))
   (case "weakness"
    (unit<-unit-xmlweakness
     unit
     child))
   (else
    (copy unit
     (msg<-error
      :invalidtagfound
      (anymap
       :type base/unit
       :tag tag))))))
 :test (test
        (base/unit
         :titles "titles")
        (unit<-unit-xmlchild
         (empty base/unit)
         (xml/xml
          :tag "titles"
          :children
           (xml/xmllist
            (xml/xml
             :text "titles")))))
 :doc "Returns a modified unit based on a given child Xml.")

(func unit<-unit-xmlpower : base/unit
 [unit     : base/unit
  xmlpower : xml/xml]
 (let : base/unit
  [unitpower : base/unitpower :=
    (unitpower<-xml
     xmlpower)
   name : string := (:name unitpower)
   origmap : base/unitpowermap := (:unitpowermap unit)
   chgmap : base/unitpowermap :=
    (copy origmap
     name unitpower)]
  (copy unit
   :unitpowermap chgmap))
 :doc "Return a unit with new unit added to unitpowermap")

(func unit<-unit-xmlskill : base/unit
 [unit     : base/unit
  xmlskill : xml/xml]
 (let : base/unit
  [unitskill : base/unitskill :=
    (unitskill<-xml
     xmlskill)
   name : string := (:name unitskill)
   origmap : base/unitskillmap := (:unitskillmap unit)
   chgmap  : base/unitskillmap :=
    (copy unitskillmap
     name unitskill)]
  (copy unit
   :unitskillmap chgmap))
 :doc "Return a unit with new unitskill added to unitskillmap")

(func unit<-unit-xmlweakness : base/unit
 [unit        : base/unit
  xmlweakness : xml/xml]
 (let : base/unit
  [unitweakness : base/unitweakness :=
    (unitweakness<-xml
     xmlweakness)
   name : string := (:name unitweakness)
   origmap : base/unitweaknessmap :=
    (:unitweaknessmap unit)
   chgmap : base/unitweaknessmap :=
    (copy origmap
     name unitweakness)]
  (copy unit
   :unitweaknessmap chgmap))
 :doc "Return a unit with new unitweakness added to unitweaknessmap")

(func unit<-xml : base/unit
 [xml : xml/xml]
 (let : base/unit
  [propmap : stringmap := (:propmap xml)
   unt : base/unit :=
    (unit<-unit-stringmap
     (empty base/unit)
     propmap)]
  (any<-list-start-reduce : base/unit
   (:children xml)
   unt
   unit<-unit-xmlchild))
 :test (test
        (base/unit
         :name "name"
         :image "image"
         :titles "titles"
         :reference "reference"
         :unitskillmap
          (base/unitskillmap
           "skill1" (base/unitskill
                     :name "skill1")))
        (unit<-xml
         (xml/xml
          :tag "unit"
          :propmap
           (stringmap
            :name "name"
            :image "image")
          :children
           (xml/xmllist
            (xml/xml
             :tag "titles"
             :children
              (xml/xmllist
               (xml/xml
                :text "titles")))
            (xml/xml
             :tag "reference"
             :children
              (xml/xmllist
               (xml/xml
                :text "reference")))
            (xml/xml
             :tag "skill"
             :propmap
              (stringmap
               :name "skill1"))))))
 :doc "Returns a unit from a given xml.")

(func unitability<-unitability-key-value : base/unitability
 [current : base/unitability
  key     : string
  value   : string]
 (switch : base/unitability
  key
  (case "" current)
  (case
   (list
    "name"
    "image")
   (copy current
    key value))
  (else
   (copy current
    (msg<-error
     :invalidproperty
     (anymap
      :type  base/unitability
      :prop  key
      :value value)))))
 :doc "Returns a modified unitability from a key value.")

(func unitability<-unitability-stringmap : base/unitability
 [unitability : base/unitability
  propmap     : stringmap]
 (any<-map-start-reduce : base/unitability
  propmap
  unitability
  unitability<-unitability-key-value)
 :test (test
        (base/unitability
         :name "name"
         :image "image")
        (unitability<-unitability-stringmap
         (empty base/unitability)
         (stringmap
          :name "name"
          :image "image")))
 :doc "Returns a new unitability from a propmap.")

(func unitability<-unitability-xmlchild : base/unitability
 [unitability : base/unitability
  child       : xml/xml]
 (let : base/unitability
  [tag : string := (:tag child)]
  (switch : base/unitability
   tag
   (case "" unitability)
   (case
    (list
     "reference"
     "summary"
     "titles")
    (copy unitability
     tag
     (xml/string-first<-xml
      child)))
   (else
    (copy unitability
     (msg<-error
      :invalidtagfound
      (anymap
       :type base/unitability
       :tag tag))))))
 :test (test
        (base/unitability
         :titles "titles")
        (unitability<-unitability-xmlchild
         (empty base/unitability)
         (xml/xml
          :tag "titles"
          :children
           (xml/xmllist
            (xml/xml
             :text "titles")))))
 :doc "Returns a modified unitability based on a given child xml.")

(func unitability<-xml : base/unitability
 [xml : xml/xml]
 (let : base/unitability
  [propmap : stringmap := (:propmap xml)
   unitability : base/unitability :=
    (unitability<-unitability-stringmap
     (empty base/unitability)
     propmap)]
  (any<-list-start-reduce : base/unitability
   (:children xml)
   unitability
   unitability<-unitability-xmlchild))
 :test (test
        (base/unitability
         :name "name"
         :image "image"
         :titles "titles"
         :reference "reference")
        (unitability<-xml
         (xml/xml
          :tag "unitability"
          :propmap
           (stringmap
            :name "name"
            :image "image")
          :children
           (xml/xmllist
            (xml/xml
             :tag "titles"
             :children
              (xml/xmllist
               (xml/xml
                :text "titles")))
            (xml/xml
             :tag "reference"
             :children
              (xml/xmllist
               (xml/xml
                :text "reference")))))))
 :doc "Returns a unitability from a given xml.")

(func unititem<-unititem-key-value : base/unititem
 [current : base/unititem
  key     : string
  value   : string]
 (switch : base/unititem
  key
  (case "" current)
  (case
   (list
    "name"
    "image"
    "facing"
    "modifiers"
    "number"
    "rounds")
   (copy current
    key value))
  (else
   (copy current
    (msg<-error
     :invalidproperty
     (anymap
      :type  base/unititem
      :prop  key
      :value value)))))
 :doc "Returns a modified unititem from a key value.")

(func unititem<-unititem-stringmap : base/unititem
 [unititem : base/unititem
  propmap  : stringmap]
 (any<-map-start-reduce : base/unititem
  propmap
  unititem
  unititem<-unititem-key-value)
 :test (test
        (base/unititem
         :name "name"
         :image "image")
        (unititem<-unititem-stringmap
         (empty base/unititem)
         (stringmap
          :name "name"
          :image "image")))
 :doc "Returns a new unititem from a propmap.")

(func unititem<-unititem-xmlchild : base/unititem
 [unititem : base/unititem
  child    : xml/xml]
 (let : base/unititem
  [tag : string := (:tag child)]
  (switch : base/unititem
   tag
   (case "" unititem)
   (case
    (list
     "reference"
     "summary"
     "titles")
    (copy unititem
     tag
     (xml/string-first<-xml
      child)))
   (else
    (copy unititem
     (msg<-error
      :invalidtagfound
      (anymap
       :type base/unititem
       :tag tag))))))
 :test (test
        (base/unititem
         :titles "titles1")
        (unititem<-unititem-xmlchild
         (empty base/unititem)
         (xml/xml
          :tag "titles"
          :children
           (xml/xmllist
            (xml/xml
             :text "titles1")))))
 :doc "Returns a modified unititem based on a given child xml.")

(func unititem<-xml : base/unititem
 [xml : xml/xml]
 (let : base/unititem
  [propmap  : stringmap   := (:propmap xml)
   children : xml/xmllist := (:children xml)
   unititem : base/unititem :=
    (unititem<-unititem-stringmap
     (empty base/unititem)
     propmap)]
  (any<-list-start-reduce : base/unititem
   children
   unititem
   unititem<-unititem-xmlchild))
 :test (test
        (base/unititem
         :name "name1"
         :image "image1"
         :titles "titles1"
         :reference "reference1"
         :summary "summary1")
        (unititem<-xml
         (xml/xml
          :tag "unititem"
          :propmap
           (stringmap
            :name "name1"
            :image "image1")
          :children
           (xml/xmllist
            (xml/xml
             :tag "titles"
             :children
              (xml/xmllist
               (xml/xml
                :text "titles1")))
            (xml/xml
             :tag "reference"
             :children
              (xml/xmllist
               (xml/xml
                :text "reference1")))
            (xml/xml
             :tag "summary"
             :children
              (xml/xmllist
               (xml/xml
                :text "summary1")))))))
 :doc "Returns a unititem from a given xml.")

(func unitpower<-unitpower-key-value : base/unitpower
 [current : base/unitpower
  key     : string
  value   : string]
 (switch : base/unitpower
  key
  (case "" current)
  (case
   (list
    "name"
    "image"
    "back"
    "bottom"
    "front"
    "level"
    "over"
    "side"
    "strength"
    "under")
   (copy current
    key value))
  (else
   (copy current
    (msg<-error
     :invalidproperty
     (anymap
      :type  base/unitpower
      :prop  key
      :value value)))))
 :doc "Returns a modified unitpower from a key value.")

(func unitpower<-unitpower-stringmap : base/unitpower
 [unitpower : base/unitpower
  propmap   : stringmap]
 (any<-map-start-reduce
  propmap
  unitpower
  unitpower<-unitpower-key-value)
 :doc "Returns a new unitpower from a propmap.")

(func unitpower<-unitpower-xmlability : base/unitpower
 [unitpower  : base/unitpower
  xmlability : xml/xml]
 (let : base/unitpower
  [ability : base/unitability :=
    (unitability<-xml
     xmlability)
   name : string := (:name ability)
   origmap : base/unitabilitymap :=
    (:unitabilitymap unitpower)
   chgmap : base/unitabilitymap :=
    (copy origmap
     name ability)]
  (copy unitpower
   :unitabilitymap chgmap))
 :doc "")

(func unitpower<-unitpower-xmlchild : base/unitpower
 [unitpower : base/unitpower
  child     : xml/xml]
 (let : base/unitpower
  [tag : string := (:tag child)]
  (switch : base/unitpower
   tag
   (case "" unitpower)
   (case
    (list
     "reference"
     "summary"
     "titles")
    (copy unitpower
     tag
     (xml/string-first<-xml
      child)))
   (case "ability"
    (unitpower<-unitpower-xmlability
     unitpower
     child))
   (case "item"
    (unitpower<-unitpower-xmlitem
     unitpower
     child))
   (case "specialty"
    (unitpower<-unitpower-xmlspecialty
     unitpower
     child))
   (else
    (copy unitpower
     (msg<-error
      :invalidtagfound
      (anymap
       :type base/unitpower
       :tag tag))))))
 :test (test
        (base/unitpower
         :summary "summary1")
        (unitpower<-unitpower-xmlchild
         (empty base/unitpower)
         (xml/xml
          :tag "summary"
          :children
           (xml/xmllist
            (xml/xml
             :text "summary1")))))
 :doc "")

(func unitpower<-unitpower-xmlitem : base/unitpower
 [unitpower : base/unitpower
  xmlitem   : xml/xml]
 (let : base/unitpower
  [item : base/unititem :=
    (unititem<-xml
     xmlitem)
   name : string := (:name item)
   origmap : base/unititemmap :=
    (:unititemmap unitpower)
   chgmap : base/unititemmap :=
    (copy origmap
     name item)]
  (copy unitpower
   :unititemmap chgmap))
 :doc "")

(func unitpower<-unitpower-xmlspecialty : base/unitpower
 [unitpower    : base/unitpower
  xmlspecialty : xml/xml]
 (let : base/unitpower
  [specialty : base/unitspecialty :=
    (unitspecialty<-xml
     xmlspecialty)
   name : string := (:name specialty)
   origmap : base/unitspecialtymap :=
    (:unitspecialtymap unitpower)
   chgmap : base/unitspecialtymap :=
    (copy origmap
     name specialty)]
  (copy unitpower
   :unitspecialtymap chgmap))
 :doc "")

(func unitpower<-xml : base/unitpower
 [xml : xml/xml]
 (let : base/unitpower
  [propmap : stringmap := (:propmap xml)
   unitpower : base/unitpower :=
    (unitpower<-unitpower-stringmap
     (empty base/unitpower)
     propmap)]
  (any<-list-start-reduce : base/unitpower
   (:children xml)
   unitpower
   unitpower<-unitpower-xmlchild))
 :doc "")

(func unitskill<-unitskill-key-value : base/unitskill
 [current : base/unitskill
  key     : string
  value   : string]
 (switch : base/unitskill
  key
  (case "" current)
  (case
   (list
    "name"
    "image"
    "back"
    "bottom"
    "front"
    "level"
    "side"
    "top")
   (copy current
    key value))
  (else
   (copy current
    (msg<-error
     :invalidproperty
     (anymap
      :type  base/unitskill
      :prop  key
      :value value)))))
 :doc "Returns a modified unitskill from a key value.")

(func unitskill<-unitskill-stringmap : base/unitskill
 [unitskill : base/unitskill
  propmap   : stringmap]
 (any<-map-start-reduce
  propmap
  unitskill
  unitskill<-unitskill-key-value)
 :doc "Returns a new unitskill from a propmap.")

(func unitskill<-unitskill-xmlability : base/unitskill
 [unitskill  : base/unitskill
  xmlability : xml/xml]
 (let : base/unitskill
  [unitability : base/unitability :=
    (unitability<-xml
     xmlability)
   name : string :=
    (:name unitability)
   origmap : base/unitabilitymap :=
    (:unitabilitymap unitskill)
   chgmap  : base/unitabilitymap :=
    (copy origmap
     name
     unitability)]
  (copy unitskill
   :unitabilitymap chgmap))
 :doc "")

(func unitskill<-unitskill-xmlchild : base/unitskill
 [unitskill : base/unitskill
  child     : xml/xml]
 (let : base/unitskill
  [tag : string := (:tag child)]
  (switch : base/unitskill
   tag
   (case "" unitskill)
   (case
    (list
     "reference"
     "summary"
     "titles")
    (copy unitskill
     tag
     (xml/string-first<-xml
      child)))
   (case "ability"
    (unitskill<-unitskill-xmlability
     unitskill
     child))
   (case "item"
    (unitskill<-unitskill-xmlitem
     unitskill
     child))
   (case "specialty"
    (unitskill<-unitskill-xmlspecialty
     unitskill
     child))
   (else
    (copy unitskill
     (msg<-error
      :invalidtagfound
      (anymap
       :type base/unitskill
       :tag tag))))))
 :test (test
        (base/unitskill
         :summary "summary1")
        (unitskill<-unitskill-xmlchild
         (empty base/unitskill)
         (xml/xml
          :tag "summary"
          :children
           (xml/xmllist
            (xml/xml
             :text "summary1")))))
 :doc "")

(func unitskill<-unitskill-xmlitem : base/unitskill
 [unitskill : base/unitskill
  xmlitem   : xml/xml]
 (let : base/unitskill
  [item    : base/unititem    := (unititem<-xml
                                  xmlitem)
   name    : string           := (:name item)
   origmap : base/unititemmap := (:unititemmap unitskill)
   chgmap  : base/unititemmap := (copy origmap
                                  name
                                  item)]
  (copy unitskill
   :unititemmap chgmap))
 :doc "")

(func unitskill<-unitskill-xmlspecialty : base/unitskill
 [unitskill    : base/unitskill
  xmlspecialty : xml/xml]
 (let : base/unitskill
  [specialty : base/unitspecialty :=
    (unitspecialty<-xml
     xmlspecialty)
   name : string :=
    (:name specialty)
   origmap : base/unitspecialtymap :=
    (:unitspecialtymap unitskill)
   chgmap : base/unitspecialtymap :=
    (copy origmap
     name specialty)]
  (copy unitskill
   :unitspecialtymap chgmap))
 :doc "")

(func unitskill<-xml : base/unitskill
 [xml : xml/xml]
 (let : base/unitskill
  [propmap : stringmap := (:propmap xml)
   unitskill : base/unitskill :=
    (unitskill<-unitskill-stringmap
     (empty base/unitskill)
     propmap)]
  (any<-list-start-reduce : base/unitskill
   (:children xml)
   unitskill
   unitskill<-unitskill-xmlchild))
 :doc "")

(func unitspecialty<-unitspecialty-key-value : base/unitspecialty
 [current : base/unitspecialty
  key     : string
  value   : string]
 (switch : base/unitspecialty
  key
  (case "" current)
  (case
   (list
    "name"
    "image")
   (copy current
    key value))
  (else
   (copy current
    (msg<-error
     :invalidproperty
     (anymap
      :type  base/unitspecialty
      :prop  key
      :value value)))))
 :doc "Returns a modified unitspecialty from a key value.")

(func unitspecialty<-unitspecialty-stringmap : base/unitspecialty
 [unitspecialty : base/unitspecialty
  propmap     : stringmap]
 (any<-map-start-reduce : base/unitspecialty
  propmap
  unitspecialty
  unitspecialty<-unitspecialty-key-value)
 :test (test
        (base/unitspecialty
         :name "name"
         :image "image")
        (unitspecialty<-unitspecialty-stringmap
         (empty base/unitspecialty)
         (stringmap
          :name "name"
          :image "image")))
 :doc "Returns a new unitspecialty from a propmap.")

(func unitspecialty<-unitspecialty-xmlchild : base/unitspecialty
 [unitspecialty : base/unitspecialty
  child       : xml/xml]
 (let : base/unitspecialty
  [tag : string := (:tag child)]
  (switch : base/unitspecialty
   tag
   (case "" unitspecialty)
   (case
    (list
     "reference"
     "summary"
     "titles")
    (copy unitspecialty
     tag
     (xml/string-first<-xml
      child)))
   (else
    (copy unitspecialty
     (msg<-error
      :invalidtagfound
      (anymap
       :type base/unitspecialty
       :tag tag))))))
 :test (test
        (base/unitspecialty
         :titles "titles")
        (unitspecialty<-unitspecialty-xmlchild
         (empty base/unitspecialty)
         (xml/xml
          :tag "titles"
          :children
           (xml/xmllist
            (xml/xml
             :text "titles")))))
 :doc "Returns a modified unitspecialty based on a given child xml.")

(func unitspecialty<-xml : base/unitspecialty
 [xml : xml/xml]
 (let : base/unitspecialty
  [propmap : stringmap := (:propmap xml)
   unitspecialty : base/unitspecialty :=
    (unitspecialty<-unitspecialty-stringmap
     (empty base/unitspecialty)
     propmap)]
  (any<-list-start-reduce : base/unitspecialty
   (:children xml)
   unitspecialty
   unitspecialty<-unitspecialty-xmlchild))
 :test (test
        (base/unitspecialty
         :name "name"
         :image "image"
         :titles "titles"
         :reference "reference")
        (unitspecialty<-xml
         (xml/xml
          :tag "unitspecialty"
          :propmap
           (stringmap
            :name "name"
            :image "image")
          :children
           (xml/xmllist
            (xml/xml
             :tag "titles"
             :children
              (xml/xmllist
               (xml/xml
                :text "titles")))
            (xml/xml
             :tag "reference"
             :children
              (xml/xmllist
               (xml/xml
                :text "reference")))))))
 :doc "Returns a unitspecialty from a given xml.")

(func unitweakness<-xml : base/unitweakness
 [xml : xml/xml])

(func weakness<-xml : base/weakness
 [xml : xml/xml])

(func xml-read<-bookname : xml/xml
 [bookname : string]
 (xml/xml-read<-file
  (file-read<-bookname
   bookname))
 :context
 :doc "Returns an xml from a file with bookname.")
