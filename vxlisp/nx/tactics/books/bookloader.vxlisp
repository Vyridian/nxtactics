(package nx/tactics/books/bookloader
 :libs (lib base :path nx/tactics/base)
       (lib fil  :path vx/data/file)
       (lib typ  :path vx/type)
       (lib xml  :path vx/data/xml)
 :doc "Book loading tools")

(func ability<-ability-key-value : base/ability
 [current : base/ability
  key     : string
  value   : string]
 (switch : base/ability
  key
  (case "" current)
  (case
   (list
    "name"
    "image")
   (copy current
    key value))
  (else
   (copy current
    (msg<-error
     :invalidproperty
     (anymap
      :type  base/ability
      :prop  key
      :value value)))))
 :doc "Returns a modified ability from a key value.")

(func ability<-ability-stringmap : base/ability
 [ability : base/ability
  propmap : stringmap]
 (any<-map-start-reduce : base/ability
  propmap
  ability
  ability<-ability-key-value)
 :test (test
        (base/ability
         :name "name"
         :image "image")
        (ability<-ability-stringmap
         (empty base/ability)
         (stringmap
          :name "name"
          :image "image")))
 :doc "Returns a new ability from a propmap.")

(func ability<-ability-xmlchild : base/ability
 [abl   : base/ability
  child : xml/xml]
 (switch : base/ability
  (:tag child)
  (case "" abl)
  (case
   (list
    "reference"
    "summary"
    "titles")
   (copy abl
    (:tag child)
    (xml/string-first<-xml
     child)))
  (else
   (copy abl
    (msg<-error
     :invalidtagfound
     (anymap
      :type base/ability
      :tag (:tag child))))))
 :test (test
        (base/ability
         :titles "titles")
        (ability<-ability-xmlchild
         (empty base/ability)
         (xml/xml
          :tag "titles"
          :children
           (xml/xmllist
            (xml/xml
             :text "titles")))))
 :doc "Returns a modified ability based on a given child xml.")

(func ability<-xml : base/ability
 [xml : xml/xml]
 (let : base/ability
  [propmap  : stringmap    := (:propmap xml)
   ability  : base/ability := (ability<-ability-stringmap
                               (empty base/ability)
                               propmap)]
  (any<-list-start-reduce : base/ability
   (:children xml)
   ability
   ability<-ability-xmlchild))
 :test (test
        (base/ability
         :name "name"
         :image "image"
         :titles "titles"
         :reference "reference")
        (ability<-xml
         (xml/xml
          :tag "ability"
          :propmap
           (stringmap
            :name "name"
            :image "image")
          :children
           (xml/xmllist
            (xml/xml
             :tag "titles"
             :children
              (xml/xmllist
               (xml/xml
                :text "titles")))
            (xml/xml
             :tag "reference"
             :children
              (xml/xmllist
               (xml/xml
                :text "reference")))))))
 :doc "Returns a ability from a given xml.")

(func book<-book-key-value : base/book
 [current : base/book
  key     : string
  value   : string]
 (switch : base/book
  key
  (case "" current)
  (case
   (list
    "name"
    "image")
   (copy current
    key value))
  (else
   (copy current
    (msg<-error
     :invalidproperty
     (anymap
      :type  base/book
      :prop  key
      :value value)))))
 :test (test
        (base/book
         :name "nm")
        (book<-book-key-value
         (empty base/book)
         "name"
         "nm"))
       (test
        (base/book
         :name "image")
        (book<-book-key-value
         (empty base/book)
         "name"
         "image"))
 :doc "Returns a modified book from a key value.")

(func book<-book-stringmap : base/book
 [book    : base/book
  propmap : stringmap]
 (any<-map-start-reduce : base/book
  propmap
  book
  book<-book-key-value)
 :test (test
        (base/book
         :name "name"
         :image "image")
        (book<-book-stringmap
         (empty base/book)
         (stringmap
          :name "name"
          :image "image")))
 :doc "Returns a new book from a propmap.")

(func book<-book-xml : base/book
 [current : base/book
  child   : xml/xml]
 (let : base/book
  [tag : string := (:tag child)]
  (switch : base/book
   tag
   (case "" current)
   (case "!--" current)
   (case "?xml" current)
   (case "doc"
    (if : base/book
     (then
      (is-empty current)
      (book<-xmldoc
       child))
     (else
      (copy current
       (msg<-error
        :duplicatetagfound
        (anymap
         :type base/book
         :tag tag))))))
   (else
    (copy current
     (msg<-error
      :invalidtagfound
      (anymap
       :type base/book
       :tag tag))))))
 :test (test
        (base/book
         :name "name1")
        (book<-book-xml
         (empty base/book)
         (xml/xml
          :tag "doc"
          :propmap
           (stringmap
            :name "name1"))))
       (test
        (empty base/book)
        (book<-book-xml
         (empty base/book)
         (xml/xml
          :tag "?xml")))
       (test
        (base/book
         :name "name1"
         (msgblock
          (msg
           :code ":duplicatetagfound"
           :detail
            (anymap
             :type nx/tactics/base/book
             :tag "doc")
             :severity 2)))
        (book<-book-xml
         (base/book
          :name "name1")
         (xml/xml
          :tag "doc")))
 :doc "Returns an altered book based on xml child.")

(func book<-book-xmlchapter : base/book
 [book : base/book
  xml  : xml/xml]
 (let : base/book
  [chapter : base/chapter    := (chapter<-xml
                                 xml)
   name    : string          := (:name chapter)
   origmap : base/chaptermap := (:chaptermap book)
   chgmap  : base/chaptermap := (copy origmap
                                 name chapter)]
  (copy book
   :chaptermap chgmap))
 :test (test
        (base/book
         :chaptermap
          (base/chaptermap
           :chapter1
            (base/chapter
             :name "chapter1")))
        (book<-book-xmlchapter
         (empty base/book)
         (xml/xml
          :tag "chapter"
          :propmap
           (stringmap
            :name "chapter1"))))
 :doc "Returns an altered book based on xmlchapter.")

(func book<-book-xmlchild : base/book
 [book  : base/book
  child : xml/xml]
 (let : base/book
  [tag : string := (:tag child)]
  (switch : base/book
   tag
   (case "" book)
   (case
    (list
     "reference"
     "summary"
     "titles")
    (copy book
     tag
     (xml/string-first<-xml
      child)))
   (case "chapter"
    (book<-book-xmlchapter
     book
     child))
   (else
    (copy book
     (msg<-error
      :invalidtagfound
      (anymap
       :type base/book
       :tag tag))))))
 :test (test
        (base/book
         :titles "titles")
        (book<-book-xmlchild
         (empty base/book)
         (xml/xml
          :tag "titles"
          :children
           (xml/xmllist
            (xml/xml
             :text "titles")))))
       (test
        (base/book
         :chaptermap
          (base/chaptermap
           :chapter1
            (base/chapter
             :name "chapter1")))
        (book<-book-xmlchild
         (empty base/book)
         (xml/xml
          :tag "chapter"
          :propmap
           (stringmap
            :name "chapter1"))))
 :doc "Returns a modified book based on a given child xml.")

(func book<-xml : base/book
 [xml : xml/xml]
 (book<-xmllist
  (:children xml))
 :test (test
        (base/book
         :name "name1")
        (book<-xml
         (xml/xml
          :children
           (xml/xmllist
            (xml/xml
             :tag "?xml")
            (xml/xml
             :tag "doc"
             :propmap
              (stringmap
               :name "name1"))))))
 :doc "Returns a book from a given top level xml.")

(func book<-xmldoc : base/book
 [xml : xml/xml]
 (let : base/book
  [propmap  : stringmap := (:propmap xml)
   children : xmllist   := (:children xml)
   book     : base/book := (book<-book-stringmap
                            (empty base/book)
                            propmap)]
  (any<-list-start-reduce : base/book
   children
   book
   book<-book-xmlchild))
 :test (test
        (base/book
         :name "name1"
         :image "image1"
         :titles "titles1"
         :reference "reference1"
         :chaptermap
          (base/chaptermap
           :chapter1
            (base/chapter
             :name "chapter1")))
        (book<-xmldoc
         (xml/xml
          :tag "doc"
          :propmap
           (stringmap
            :name "name1"
            :image "image1")
          :children
           (xml/xmllist
            (xml/xml
             :tag "titles"
             :children
              (xml/xmllist
               (xml/xml
                :text "titles1")))
            (xml/xml
             :tag "reference"
             :children
              (xml/xmllist
               (xml/xml
                :text "reference1")))
            (xml/xml
             :tag "chapter"
             :propmap
              (stringmap
               :name "chapter1"))))))
 :doc "Returns a book from a given xml.")

(func book<-xmllist : base/book
 [xmllist : xml/xmllist]
 (any<-list-start-reduce : base/book
  xmllist
  (empty base/book)
  book<-book-xml)
 :test (test
        (base/book
         :name "name1")
        (book<-xmllist
         (xml/xmllist
          (xml/xml
           :tag "?xml")
          (xml/xml
           :tag "doc"
           :propmap
            (stringmap
             :name "name1")))))
 :doc "Returns a book from a given xml.")

(func boolean-write<-book : boolean
 [book : base/book]
 (let : boolean
  [text : string   := (string-vxlisp<-book
                       book)
   file : fil/file := (file-write<-book
                       book)]
  (boolean-write<-file-string
   file
   text))
 :context
 :doc "Returns boolean after writing book as a file.")

(func book-read<-bookname : base/book
 [bookname : string]
 (let : base/book
  [xml : xml/xml := (xml-read<-bookname
                     bookname)]
  (book<-xml
   xml))
 :context
 :doc "Returns a book by loading the given Xml filename.")

(func boolean-write<-booknames : boolean
 [booknames : stringlist]
 (let : boolean
  [bools : booleanlist := (list<-list : booleanlist
                           booknames
                           (fn : boolean
                            [bookname : string]
                            (let : boolean
                             [book : base/book := (book-read<-bookname
                                                   bookname)]
                             (boolean-write<-book
                              book))))]
  (and bools))
 :context
 :doc "Returns boolean after writing book as a file.")

(func chapter<-chapter-key-value : base/chapter
 [current : base/chapter
  key     : string
  value   : string]
 (switch : base/chapter
  key
  (case "" current)
  (case
   (list
    "name"
    "image")
   (copy current
    key value))
  (else
   (copy current
    (msg<-error
     :invalidproperty
     (anymap
      :type  base/chapter
      :prop  key
      :value value)))))
 :doc "Returns a modified chapter from a key value.")

(func chapter<-chapter-stringmap : base/chapter
 [chapter : base/chapter
  propmap : stringmap]
 (any<-map-start-reduce : base/chapter
  propmap
  chapter
  chapter<-chapter-key-value)
 :test (test
        (base/chapter
         :name "name"
         :image "image")
        (chapter<-chapter-stringmap
         (empty base/chapter)
         (stringmap
          :name "name"
          :image "image")))
 :doc "Returns a new book from a propmap.")

(func chapter<-chapter-xmlchild : base/chapter
 [chapter : base/chapter
  child   : xml/xml]
 (switch : base/chapter
  (:tag child)
  (case "" chapter)
  (case
   (list
    "reference"
    "summary"
    "titles")
   (copy chapter
    (:tag child)
    (xml/string-first<-xml
     child)))
  (case "section"
   (chapter<-chapter-xmlsection
    chapter
    child))
  (else
   (copy chapter
    (msg<-error
     :invalidtagfound
     (anymap
      :type base/chapter
      :tag (:tag child))))))
 :test (test
        (base/chapter
         :titles "titles")
        (chapter<-chapter-xmlchild
         (empty base/chapter)
         (xml/xml
          :tag "titles"
          :children
           (xml/xmllist
            (xml/xml
             :text "titles")))))
 :doc "Returns a modified chapter based on a given child Xml.")

(func chapter<-chapter-xmlsection : base/chapter
 [chapter    : base/chapter
  xmlsection : xml/xml]
 (let : base/chapter
  [section    : base/section    := (section<-xml
                                    xmlsection)
   name       : string          := (:name section)
   sectionmap : base/sectionmap := (:sectionmap section)
   chgmap     : base/sectionmap := (copy sectionmap
                                    name
                                    section)]
  (copy chapter
   :sectionmap chgmap))
 :doc "Return a chapter with new section added to sectionmap")

(func chapter<-xml : base/chapter
 [xml : xml/xml]
 (let : base/chapter
  [propmap : stringmap    := (:propmap xml)
   chap    : base/chapter := (chapter<-chapter-stringmap
                              (empty base/chapter)
                              propmap)]
  (any<-list-start-reduce : base/chapter
   (:children xml)
   chap
   chapter<-chapter-xmlchild))
 :test (test
        (base/chapter
         :name "name"
         :image "image"
         :titles "titles"
         :reference "reference"
         :sectionmap
          (base/sectionmap
           :section1
            (base/section
             :name "section1")))
        (chapter<-xml
         (xml/xml
          :tag "chapter"
          :propmap
           (stringmap
            :name "name"
            :image "image")
          :children
           (xml/xmllist
            (xml/xml
             :tag "titles"
             :children
              (xml/xmllist
               (xml/xml
                :text "titles")))
            (xml/xml
             :tag "reference"
             :children
              (xml/xmllist
               (xml/xml
                :text "reference")))
            (xml/xml
             :tag "section"
             :propmap
              (stringmap
               :name "section1"))))))
 :doc "Returns a chapter from a given Xml.")

(func file-read<-bookname : fil/file
 [bookname : string]
 (fil/file
  :path "resources/books"
  :name (string
         bookname
         ".xml"))
 :doc "Returns a file from a bookname.")

(func file-write<-book : fil/file
 [book : base/book]
 (let : fil/file
  [bookname : string := (string-writename<-book
                         book)]
  (fil/file
   :path "resources/books"
   :name (string
          bookname
          ".vxlisp")))
 :doc "Returns a file with string from book")

(func modifier<-xml : base/modifier)

(func power<-power-key-value : base/power
 [current : base/power
  key     : string
  value   : string]
 (switch : base/power
  key
  (case "" current)
  (case
   (list
    "name"
    "image")
   (copy current
    key value))
  (else
   (copy current
    (msg<-error
     :invalidproperty
     (anymap
      :type  base/power
      :prop  key
      :value value)))))
 :doc "Returns a modified power from a key value.")

(func power<-power-stringmap : base/power
 [power   : base/power
  propmap : stringmap]
 (any<-map-start-reduce : base/power
  propmap
  power
  power<-power-key-value)
 :test (test
        (base/power
         :name "name"
         :image "image")
        (power<-power-stringmap
         (empty base/power)
         (stringmap
          :name "name"
          :image "image")))
 :doc "Returns a new power from a propmap.")

(func power<-power-xmlchild : base/power
 [power : base/power
  child : xml/xml]
 (let : base/power
  [tag : string := (:tag child)]
  (switch : base/power
   tag
   (case "" power)
   (case
    (list
     "reference"
     "summary"
     "titles")
    (copy power
     tag
     (xml/string-first<-xml
      child)))
   (case "ability"
    (power<-power-xmlability
     power
     child))
   (case "specialty"
    (power<-power-xmlspecialty
     power
     child))
   (else
    (copy power
     (msg<-error
      :invalidtagfound
      (anymap
       :type base/power
       :tag tag))))))
 :test (test
        (base/power
         :titles "titles")
        (power<-power-xmlchild
         (empty base/power)
         (xml/xml
          :tag "titles"
          :children
           (xml/xmllist
            (xml/xml
             :text "titles")))))
 :doc "Returns a modified power based on a given child xml.")

(func power<-xml : base/power
 [xml : xml/xml]
 (let : base/power
  [propmap  : stringmap  := (:propmap xml)
   children : xmllist    := (:children xml)
   power    : base/power := (power<-power-stringmap
                             (empty base/power)
                             propmap)]
  (any<-list-start-reduce : base/power
   children
   power
   power<-power-xmlchild))
 :test (test
        (base/power
         :name "name"
         :image "image"
         :titles "titles"
         :reference "reference"
         :abilitymap
          (base/abilitymap
           :ability1
            (base/ability
             :name "ability1"))
         :specialtymap
          (base/specialtymap
           :specialty1
            (base/specialty
             :name "specialty1")))
        (power<-xml
         (xml/xml
          :tag "power"
          :propmap
           (stringmap
            :name "name"
            :image "image")
          :children
           (xml/xmllist
            (xml/xml
             :tag "titles"
             :children
              (xml/xmllist
               (xml/xml
                :text "titles")))
            (xml/xml
             :tag "reference"
             :children
              (xml/xmllist
               (xml/xml
                :text "reference")))
            (xml/xml
             :tag "ability"
             :propmap
              (stringmap
               :name "ability1"))
            (xml/xml
             :tag "specialty"
             :propmap
              (stringmap
               :name "specialty1"))))))
 :doc "Returns a power from a given Xml.")

(func power<-power-xmlability : base/power
 [power      : base/power
  xmlability : xml/xml]
 (let : base/power
  [ability : base/ability    := (ability<-xml
                                 xmlability)
   name    : string          := (:name ability)
   origmap : base/abilitymap := (:abilitymap power)
   chgmap  : base/abilitymap := (copy origmap
                                 name
                                 ability)]
  (copy power
   :abilitymap chgmap))
 :doc "Return a power with new ability added to abilitymap")

(func power<-power-xmlspecialty : base/power
 [power        : base/power
  xmlspecialty : xml/xml]
 (let : base/power
  [specialty : base/specialty    := (specialty<-xml
                                     xmlspecialty)
   name      : string            := (:name specialty)
   origmap   : base/specialtymap := (:specialtymap power)
   chgmap    : base/specialtymap := (copy origmap
                                     name
                                     specialty)]
  (copy power
   :specialtymap chgmap))
 :doc "Return a power with new specialty added to specialtymap")

(func rule<-rule-key-value : base/rule
 [current : base/rule
  key     : string
  value   : string]
 (switch : base/rule
  key
  (case "" current)
  (case
   (list
    "name"
    "image")
   (copy current
    key value))
  (else
   (copy current
    (msg<-error
     :invalidproperty
     (anymap
      :type  base/rule
      :prop  key
      :value value)))))
 :doc "Returns a modified rule from a key value.")

(func rule<-rule-stringmap : base/rule
 [rule    : base/rule
  propmap : stringmap]
 (any<-map-start-reduce : base/rule
  propmap
  rule
  rule<-rule-key-value)
 :test (test
        (base/rule
         :name  "name"
         :image "image")
        (rule<-rule-stringmap
         (empty base/rule)
         (stringmap
          :name  "name"
          :image "image")))
 :doc "Returns a rule from a propmap.")

(func rule<-rule-xmlchild : base/rule
 [rule  : base/rule
  child : xml/xml]
 (switch : base/rule
  (:tag child)
  (case "" rule)
  (case
   (list
    "reference"
    "summary"
    "titles")
   (copy rule
    (:tag child)
    (xml/string-first<-xml
     child)))
  (else
   (copy rule
    (msg<-error
     :invalidtagfound
     (anymap
      :type base/rule
      :tag (:tag child))))))
 :test (test
        (base/rule
         :titles "titles")
        (rule<-rule-xmlchild
         (empty base/rule)
         (xml/xml
          :tag "titles"
          :children
           (xml/xmllist
            (xml/xml
             :text "titles")))))
 :doc "Returns a modified rule based on a given child Xml.")

(func rule<-xml : base/rule
 [xml : xml/xml]
 (let : base/rule
  [propmap : stringmap := (:propmap xml)
   rul     : base/rule := (rule<-rule-stringmap
                           (empty base/rule)
                           propmap)]
  (any<-list-start-reduce : base/rule
   (:children xml)
   rul
   rule<-rule-xmlchild))
 :doc "Returns a rule from a given xml.")

(func scenario<-scenario-key-value : base/scenario
 [current : base/scenario
  key     : string
  value   : string]
 (switch : base/scenario
  key
  (case "" current)
  (case
   (list
    "name"
    "image")
   (copy current
    key value))
  (else
   (copy current
    (msg<-error
     :invalidproperty
     (anymap
      :type  base/scenario
      :prop  key
      :value value)))))
 :doc "Returns a modified scenario from a key value.")

(func scenario<-scenario-stringmap : base/scenario
 [scenario : base/scenario
  propmap  : stringmap]
 (any<-map-start-reduce : base/scenario
  propmap
  scenario
  scenario<-scenario-key-value)
 :doc "Returns a scenario from a propmap.")

(func scenario<-scenario-xmlchild : base/scenario
 [scenario : base/scenario
  child    : xml/xml]
 (switch : base/scenario
  (:tag child)
  (case "" scenario)
  (case
   (list
    "reference"
    "summary"
    "titles")
   (copy scenario
    (:tag child)
    (xml/string-first<-xml
     child)))
  (else
   (copy scenario
    (msg<-error
     :invalidtagfound
     (anymap
      :type base/scenario
      :tag (:tag child))))))
 :doc "Returns a modified scenario based on a given child Xml.")

(func scenario<-xml : base/scenario
 [xml : xml/xml]
 (let : base/scenario
  [propmap : stringmap     := (:propmap xml)
   scen    : base/scenario := (scenario<-scenario-stringmap
                               (empty base/scenario)
                               propmap)]
  (any<-list-start-reduce : base/scenario
   (:children xml)
   scen
   scenario<-scenario-xmlchild))
 :test (test
        (base/scenario
         :name "name"
         :image "image"
         :titles "titles"
         :reference "reference")
        (scenario<-xml
         (xml/xml
          :tag "scenario"
          :propmap
           (stringmap
            :name "name"
            :image "image")
          :children
           (xml/xmllist
            (xml/xml
             :tag "titles"
             :children
              (xml/xmllist
               (xml/xml
                :text "titles")))
            (xml/xml
             :tag "reference"
             :children
              (xml/xmllist
               (xml/xml
                :text "reference")))))))
 :doc "Returns a scenario from a given Xml.")

(func section<-section-key-value : base/section
 [current : base/section
  key     : string
  value   : string]
 (switch : base/section
  key
  (case "" current)
  (case
   (list
    "name"
    "image")
   (copy current
    key value))
  (else
   (copy current
    (msg<-error
     :invalidproperty
     (anymap
      :type  base/section
      :prop  key
      :value value)))))
 :doc "Returns a modified section from a key value.")

(func section<-section-stringmap : base/section
 [section : base/section
  propmap : stringmap]
 (any<-map-start-reduce : base/section
  propmap
  section
  section<-section-key-value)
 :doc "Returns a new book from a propmap.")

(func section<-section-xmlchild : base/section
 [section : base/section
  child   : xml/xml]
 (let : base/section
  [tag : string := (:tag child)]
  (switch : base/section
   tag
   (case "" section)
   (case
    (list
     "reference"
     "summary"
     "titles")
    (copy section
     tag
     (xml/string-first<-xml
      child)))
   (case "power"
    (section<-section-xmlpower
     section
     child))
   (case "rule"
    (section<-section-xmlrule
     section
     child))
   (case "scenario"
    (section<-section-xmlscenario
     section
     child))
   (case "section"
    (section<-section-xmlsection
     section
     child))
   (case "skill"
    (section<-section-xmlskill
     section
     child))
   (case "unit"
    (section<-section-xmlunit
     section
     child))
   (else
    (copy section
     (msg<-error
      :invalidtagfound
      (anymap
       :type base/section
       :tag tag))))))
 :doc "Returns a modified section based on a given child Xml.")

(func section<-section-xmlpower : base/section
 [section  : base/section
  xmlpower : xml/xml]
 (let : base/section
  [power   : base/power    := (power<-xml
                               xmlpower)
   name    : string        := (:name power)
   origmap : base/powermap := (:powermap section)
   chgmap  : base/powermap := (copy origmap
                               name
                               power)]
  (copy section
   :powermap chgmap))
 :doc "Return a section with new power added to powermap")

(func section<-section-xmlrule : base/section
 [section    : base/section
  xmlrule    : xml/xml]
 (let : base/section
  [rule    : base/rule    := (rule<-xml
                              xmlrule)
   name    : string       := (:name rule)
   rulemap : base/rulemap := (:rulemap section)
   chgmap  : base/rulemap := (copy rulemap
                              name
                              rule)]
  (copy section
   :rulemap chgmap))
 :doc "Return a section with new rule added to rulemap")

(func section<-section-xmlscenario : base/section
 [section     : base/section
  xmlscenario : xml/xml]
 (let : base/section
  [scenario    : base/scenario    := (scenario<-xml
                                      xmlscenario)
   name        : string           := (:name scenario)
   scenariomap : base/scenariomap := (:scenariomap section)
   chgmap      : base/scenariomap := (copy scenariomap
                                      name
                                      scenario)]
  (copy section
   :scenariomap chgmap))
 :doc "Return a section with new scenario added to scenariomap")

(func section<-section-xmlsection : base/section
 [section    : base/section
  xmlsection : xml/xml]
 (let : base/section
  [subsect    : base/section    := (section<-xml
                                    xmlsection)
   name       : string          := (:name subsect)
   sectionmap : base/sectionmap := (:sectionmap section)
   chgmap     : base/sectionmap := (copy sectionmap
                                    name
                                    subsect)]
  (copy section
   :sectionmap chgmap))
 :doc "Return a section with new section added to sectionmap")

(func section<-section-xmlskill : base/section
 [section  : base/section
  xmlskill : xml/xml]
 (let : base/section
  [skill   : base/skill    := (skill<-xml
                               xmlskill)
   name    : string        := (:name skill)
   origmap : base/skillmap := (:skillmap section)
   chgmap  : base/skillmap := (copy origmap
                               name
                               skill)]
  (copy section
   :skillmap chgmap))
 :doc "Return a section with new skill added to skillmap")

(func section<-section-xmlunit : base/section
 [section : base/section
  xmlunit : xml/xml]
 (let : base/section
  [unit    : base/unit    := (unit<-xml
                              xmlunit)
   name    : string       := (:name unit)
   unitmap : base/unitmap := (:unitmap section)
   chgmap  : base/unitmap := (copy unitmap
                              name
                              unit)]
  (copy section
   :unitmap chgmap))
 :doc "Return a section with new unit added to unitmap")

(func section<-xml : base/section
 [xml : xml/xml]
 (let : base/section
  [propmap  : stringmap    := (:propmap  xml)
   children : xml/xmllist  := (:children xml)
   section  : base/section := (section<-section-stringmap
                               (empty base/section)
                               propmap)]
  (any<-list-start-reduce : base/section
   children
   section
   section<-section-xmlchild))
 :test (test
        (base/section
         :name "name"
         :image "image"
         :titles "titles"
         :reference "reference"
         :powermap
          (base/powermap
           :power1
            (base/power
             :name "power1"))
         :scenariomap
          (base/scenariomap
           :scenario1
            (base/scenario
             :name "scenario1"))
         :sectionmap
          (base/sectionmap
           :section1
            (base/section
             :name "section1"))
         :skillmap
          (base/skillmap
           :skill1
            (base/skill
             :name "skill1")))
        (section<-xml
         (xml/xml
          :tag "section"
          :propmap
           (stringmap
            :name "name"
            :image "image")
          :children
           (xml/xmllist
            (xml/xml
             :tag "titles"
             :children
              (xml/xmllist
               (xml/xml
                :text "titles")))
            (xml/xml
             :tag "reference"
             :children
              (xml/xmllist
               (xml/xml
                :text "reference")))
            (xml/xml
             :tag "power"
             :propmap
              (stringmap
               :name "power1"))
            (xml/xml
             :tag "scenario"
             :propmap
              (stringmap
               :name "scenario1"))
            (xml/xml
             :tag "section"
             :propmap
              (stringmap
               :name "section1"))
            (xml/xml
             :tag "skill"
             :propmap
              (stringmap
               :name "skill1"))))))
 :doc "Returns a section from a given Xml.")

(func skill<-skill-key-value : base/skill
 [current : base/skill
  key     : string
  value   : string]
 (switch : base/skill
  key
  (case "" current)
  (case
   (list
    "name"
    "image")
   (copy current
    key value))
  (else
   (copy current
    (msg<-error
     :invalidproperty
     (anymap
      :type  base/skill
      :prop  key
      :value value)))))
 :doc "Returns a modified skill from a key value.")

(func skill<-skill-stringmap : base/skill
 [skill : base/skill
  propmap : stringmap]
 (any<-map-start-reduce : base/skill
  propmap
  skill
  skill<-skill-key-value)
 :doc "Returns a new skill from a propmap.")

(func skill<-skill-xmlchild : base/skill
 [skill : base/skill
  child : xml/xml]
 (let : base/skill
  [tag : string := (:tag child)]
  (switch : base/skill
   tag
   (case "" skill)
   (case
    (list
     "reference"
     "summary"
     "titles")
    (copy skill
     tag
     (xml/string-first<-xml
     child)))
   (case "ability"
    (skill<-skill-xmlability
     skill
     child))
   (case "specialty"
    (skill<-skill-xmlspecialty
     skill
     child))
   (else
    (copy skill
     (msg<-error
      :invalidtagfound
      (anymap
       :type base/skill
       :tag tag))))))
 :test (test
        (base/skill
         :titles "titles")
        (skill<-skill-xmlchild
         (empty base/skill)
         (xml/xml
          :tag "titles"
          :children
           (xml/xmllist
            (xml/xml
             :text "titles")))))
 :doc "Returns a modified skill based on a given child Xml.")

(func skill<-skill-xmlability : base/skill
 [skill      : base/skill
  xmlability : xml/xml]
 (let : base/skill
  [ability : base/ability    := (ability<-xml
                                 xmlability)
   name    : string          := (:name ability)
   origmap : base/abilitymap := (:abilitymap skill)
   chgmap  : base/abilitymap := (copy origmap
                                 name
                                 ability)]
  (copy skill
   :abilitymap chgmap))
 :doc "Return a skill with new ability added to abilitymap")

(func skill<-skill-xmlspecialty : base/skill
 [skill        : base/skill
  xmlspecialty : xml/xml]
 (let : base/skill
  [specialty : base/specialty    := (specialty<-xml
                                     xmlspecialty)
   name      : string            := (:name specialty)
   origmap   : base/specialtymap := (:specialtymap skill)
   chgmap    : base/specialtymap := (copy origmap
                                     name
                                     specialty)]
  (copy skill
   :specialtymap chgmap))
 :doc "Return a skill with new specialty added to specialtymap")

(func skill<-xml : base/skill
 [xml : xml/xml]
 (let : base/skill
  [propmap : stringmap  := (:propmap xml)
   skl     : base/skill := (skill<-skill-stringmap
                            (empty base/skill)
                            propmap)]
  (any<-list-start-reduce : base/skill
   (:children xml)
   skl
   skill<-skill-xmlchild))
 :test (test
        (base/skill
         :name "name"
         :image "image"
         :titles "titles"
         :reference "reference"
         :abilitymap
          (base/abilitymap
           :ability1
            (base/ability
             :name "ability1"))
         :specialtymap
          (base/specialtymap
           :specialty1
            (base/specialty
             :name "specialty1")))
        (skill<-xml
         (xml/xml
          :tag "skill"
          :propmap
           (stringmap
            :name "name"
            :image "image")
          :children
           (xml/xmllist
            (xml/xml
             :tag "titles"
             :children
              (xml/xmllist
               (xml/xml
                :text "titles")))
            (xml/xml
             :tag "reference"
             :children
              (xml/xmllist
               (xml/xml
                :text "reference")))
            (xml/xml
             :tag "ability"
             :propmap
              (stringmap
               :name "ability1"))
            (xml/xml
             :tag "specialty"
             :propmap
              (stringmap
               :name "specialty1"))))))
 :doc "Returns a skill from a given xml.")

(func specialty<-specialty-key-value : base/specialty
 [current : base/specialty
  key     : string
  value   : string]
 (switch : base/specialty
  key
  (case "" current)
  (case
   (list
    "name"
    "image")
   (copy current
    key value))
  (else
   (copy current
    (msg<-error
     :invalidproperty
     (anymap
      :type  base/specialty
      :prop  key
      :value value)))))
 :doc "Returns a modified specialty from a key value.")

(func specialty<-specialty-stringmap : base/specialty
 [specialty : base/specialty
  propmap   : stringmap]
 (any<-map-start-reduce : base/specialty
  propmap
  specialty
  specialty<-specialty-key-value)
 :test (test
        (base/specialty
         :name "name"
         :image "image")
        (specialty<-specialty-stringmap
         (empty base/specialty)
         (stringmap
          :name "name"
          :image "image")))
 :doc "Returns a new specialty from a propmap.")

(func specialty<-specialty-xmlchild : base/specialty
 [specialty : base/specialty
  child     : xml/xml]
 (switch : base/specialty
  (:tag child)
  (case "" specialty)
  (case
   (list
    "reference"
    "summary"
    "titles")
   (copy specialty
    (:tag child)
    (xml/string-first<-xml
     child)))
  (else
   (copy specialty
    (msg<-error
     :invalidtagfound
     (anymap
      :type base/specialty
      :tag (:tag child))))))
 :test (test
        (base/specialty
         :titles "titles")
        (specialty<-specialty-xmlchild
         (empty base/specialty)
         (xml/xml
          :tag "titles"
          :children
           (xml/xmllist
            (xml/xml
             :text "titles")))))
 :doc "Returns a modified specialty based on a given child xml.")

(func specialty<-xml : base/specialty
 [xml : xml/xml]
 (let : base/specialty
  [propmap : stringmap      := (:propmap xml)
   spc     : base/specialty := (specialty<-specialty-stringmap
                                (empty base/specialty)
                                propmap)]
  (any<-list-start-reduce : base/specialty
   (:children xml)
   spc
   specialty<-specialty-xmlchild))
 :test (test
        (base/specialty
         :name "name"
         :image "image"
         :titles "titles"
         :reference "reference")
        (specialty<-xml
         (xml/xml
          :tag "specialty"
          :propmap
           (stringmap
            :name "name"
            :image "image")
          :children
           (xml/xmllist
            (xml/xml
             :tag "titles"
             :children
              (xml/xmllist
               (xml/xml
                :text "titles")))
            (xml/xml
             :tag "reference"
             :children
              (xml/xmllist
               (xml/xml
                :text "reference")))))))
 :doc "Returns a specialty from a given xml.")

(func string-read<-bookname : string
 [bookname : string]
 (string-read<-file
  (file-read<-bookname
   bookname))
 :context
 :doc "Returns text from a file with bookname.")

(func string-vxlisp<-book : string
 [book : base/book]
 (let : string
  [name : string := (bl/string-writename<-book
                     book)
   text : string := (string<-any-indent
                     book
                     1
                     false)]
   (string
    "(package nx/tactics/books/"
    name
    "\n :libs (lib base :path nx/tactics/base))\n\n(func tacticsbook : base/book\n "
    text
    ")\n"))
 :doc "Returns a vxlisp string from a book.")

(func string-writename<-book : string
 [book : base/book]
 (string<-string-find-replace
  (typ/string-lowercase
   (:name book))
  " "
  "_")
 :doc "Returns the write filename from a book")

(func unit<-unit-key-value : base/unit
 [current : base/unit
  key     : string
  value   : string]
 (switch : base/unit
  key
  (case "" current)
  (case
   (list
    "name"
    "image"
    "body"
    "height"
    "length"
    "mass"
    "mind"
    "width"
    "will")
   (copy current
    key value))
  (else
   (copy current
    (msg<-error
     :invalidproperty
     (anymap
      :type  base/unit
      :prop  key
      :value value)))))
 :doc "Returns a modified unit from a key value.")

(func unit<-unit-stringmap : base/unit
 [unit    : base/unit
  propmap : stringmap]
 (any<-map-start-reduce
  propmap
  unit
  unit<-unit-key-value)
 :test (test
        (base/unit
         :name "name"
         :image "image")
        (unit<-unit-stringmap
         (empty base/unit)
         (stringmap
          :name "name"
          :image "image")))
 :doc "Returns a new unit from a propmap.")

(func unit<-unit-xmlchild : base/unit
 [unit  : base/unit
  child : xml/xml]
 (switch : base/unit
  (:tag child)
  (case "" unit)
  (case
   (list
    "reference"
    "summary"
    "titles")
   (copy unit
    (:tag child)
    (xml/string-first<-xml
    child)))
  (case "power"
   (unit<-unit-xmlpower
    unit
    child))
  (case "skill"
   (unit<-unit-xmlskill
    unit
    child))
  (case "weakness"
   (unit<-unit-xmlweakness
    unit
    child))
  (else
   (copy unit
    (msg<-error
     :invalidtagfound
     (anymap
      :type base/unit
      :tag (:tag child))))))
 :test (test
        (base/unit
         :titles "titles")
        (unit<-unit-xmlchild
         (empty base/unit)
         (xml/xml
          :tag "titles"
          :children
           (xml/xmllist
            (xml/xml
             :text "titles")))))
 :doc "Returns a modified unit based on a given child Xml.")

(func unit<-unit-xmlpower : base/unit
 [unit     : base/unit
  xmlpower : xml/xml]
 (let : base/unit
  [unitpower    : base/unitpower    := (unitpower<-xml
                                        xmlpower)
   name         : string            := (:name unitpower)
   unitpowermap : base/unitpowermap := (:unitpowermap unit)
   chgmap       : base/unitpowermap := (copy unitpowermap
                                        name
                                        unitpower)]
  (copy unit
   :unitpowermap chgmap))
 :doc "Return a unit with new unit added to unitpowermap")

(func unit<-unit-xmlskill : base/unit
 [unit     : base/unit
  xmlskill : xml/xml]
 (let : base/unit
  [unitskill    : base/unitskill    := (unitskill<-xml
                                        xmlskill)
   name         : string            := (:name unitskill)
   unitskillmap : base/unitskillmap := (:unitskillmap unit)
   chgmap       : base/unitskillmap := (copy unitskillmap
                                        name
                                        unitskill)]
  (copy unit
   :unitskillmap chgmap))
 :doc "Return a unit with new unitskill added to unitskillmap")

(func unit<-unit-xmlweakness : base/unit
 [unit        : base/unit
  xmlweakness : xml/xml]
 (let : base/unit
  [unitweakness    : base/unitweakness    := (unitweakness<-xml
                                              xmlweakness)
   name            : string               := (:name unitweakness)
   unitweaknessmap : base/unitweaknessmap := (:unitweaknessmap unit)
   chgmap          : base/unitweaknessmap := (copy unitweaknessmap
                                              name
                                              unitweakness)]
  (copy unit
   :unitweaknessmap chgmap))
 :doc "Return a unit with new unitweakness added to unitweaknessmap")

(func unit<-xml : base/unit
 [xml : xml/xml]
 (let : base/unit
  [propmap : stringmap := (:propmap xml)
   unt     : base/unit := (unit<-unit-stringmap
                           (empty base/unit)
                           propmap)]
  (any<-list-start-reduce : base/unit
   (:children xml)
   unt
   unit<-unit-xmlchild))
 :test (test
        (base/unit
         :name "name"
         :image "image"
         :titles "titles"
         :reference "reference"
         :unitskillmap
          (base/unitskillmap
           "skill1" (base/unitskill
                     :name "skill1")))
        (unit<-xml
         (xml/xml
          :tag "unit"
          :propmap
           (stringmap
            :name "name"
            :image "image")
          :children
           (xml/xmllist
            (xml/xml
             :tag "titles"
             :children
              (xml/xmllist
               (xml/xml
                :text "titles")))
            (xml/xml
             :tag "reference"
             :children
              (xml/xmllist
               (xml/xml
                :text "reference")))
            (xml/xml
             :tag "skill"
             :propmap
              (stringmap
               :name "skill1"))))))
 :doc "Returns a unit from a given Xml.")

(func unitpower<-xml : base/unitpower
 [xml : xml/xml])

(func unitskill<-unitskill-key-value : base/unitskill
 [current : base/unitskill
  key     : string
  value   : string]
 (switch : base/unitskill
  key
  (case "" current)
  (case
   (list
    "name"
    "image")
   (copy current
    key value))
  (else
   (copy current
    (msg<-error
     :invalidproperty
     (anymap
      :type  base/unitskill
      :prop  key
      :value value)))))
 :doc "Returns a modified unitskill from a key value.")

(func unitskill<-unitskill-stringmap : base/unitskill
 [unitskill : base/unitskill
  propmap   : stringmap]
 (any<-map-start-reduce
  propmap
  unitskill
  unitskill<-unitskill-key-value)
 :doc "Returns a new unitskill from a propmap.")

(func unitskill<-unitskill-xmlchild : base/unitskill
 [unitskill : base/unitskill
  child     : xml/xml]
 (switch : base/unitskill
  (:tag child)
  (case "" unitskill)
  (case
   (list
    "reference"
    "summary"
    "titles")
   (copy unitskill
    (:tag child)
    (xml/string-first<-xml
     child)))
  (else
   (copy unitskill
    (msg<-error
     :invalidtagfound
     (anymap
      :type base/unitskill
      :tag (:tag child))))))
 :doc "")

(func unitskill<-xml : base/unitskill
 [xml : xml/xml]
 (let : base/unitskill
  [propmap : stringmap      := (:propmap xml)
   untskl  : base/unitskill := (unitskill<-unitskill-stringmap
                                (empty base/unitskill)
                                propmap)]
  (any<-list-start-reduce : base/unitskill
   (:children xml)
   untskl
   unitskill<-unitskill-xmlchild))
 :doc "")

(func unitweakness<-xml : base/unitweakness
 [xml : xml/xml])

(func weakness<-xml : base/weakness
 [xml : xml/xml])

(func xml-read<-bookname : xml/xml
 [bookname : string]
 (xml/xml-read<-file
  (file-read<-bookname
   bookname))
 :context
 :doc "Returns an xml from a file with bookname.")
